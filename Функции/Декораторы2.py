# Замыкания в Python
#  def say_name(name):
#      def say_goodbye():
#          print (f"Вызвали say_goodbye с именем {name}")
#      return say_goodbye

#f = say_name("name") записали в f функцию say_name c параметром name
#f() выведет на экран print (f"Вызвали say_goodbye с именем {name}")
# так как мы обращаемся к say_name в котором переданный атрибут name
# и вложенна функция say_goodbye которая вернет результатом своей работы свое содержимое

# Замыкания в Python. Вложенные функции
# вложенные функции работают по примеру конструкторов деструкторов в с++
# пока не вызвали деструктор из дочернего класса родительский существует
# при определении в переменную создается ссылка на вложенную функцию и матрешка существует
# так как сборщик мусора видит что данный обьект используется
# при каждом вызове будет создаваться свой экземпляр

# функция счетчик
# def counter(start = 0):
#     def step():
#         nonlocal start
#         start +=1
#         return start
#     return step
#
# c1 = counter(10)
# c2 = counter()

# при каждом вызове с1 с2 счетчик будет увеличеваться


# Декораторы функций
# Принимают ссылки на другие функции
# Позволяет выполнить РАЗНЫЕ действия до функции и после
# @ имя функции лоя дикорирования

# УНЕВЕРСАЛЬНЫЙ ДЕКОРАТОР
def func_decorator(foo):
    def wrapper(*args, **kwargs): #прописываем для уневерсального принятия параметров
        print("Действие до функции")
        res = foo(*args, **kwargs) # вызов нужной функции  и передача параметра
        print("Действие после функции")
        return res # вернули результат работы функции foo()

    return wrapper() #ООООЧЕНЬ ВАЖНО ВОЗВРАЩАТЬ ССЫЛКУ

# ФУНКЦИЯ
@func_decorator #задикорировали функцию
def func(x ="x = ПАРАМЕТР"):
    print(f"вызов func {x}")


# func(x = 1) так как задикорировали при вызове отработает блок wrapper
# print("Действие до функции")
# foo() # вызов нужной функции
# print("Действие после функции")

def decorator(func):  # Сюда передаём функцию которую нужно декорировать
    def wrapper(*args, **kwargs):  # Сюда передаём аргументы декорированной функции
        print(f'{func.__name__} started')  # декорирующие действия 1
        result = func(*args, **kwargs)  # *args -чтобы работать с разным кол-вом аргументов
        print(f'{func.__name__} finished')  # декорирующие действия 2
        return result  # возвращаем результат

    return wrapper  # передаём ссылку на вложенную функцию
#
#
@decorator  # сахар для вызова декоратора (навешиваем декоратор)
def summ(a, b):  # функция которую нужно декорировать в этот момент: summ = wrapper
    return a + b
#
#
# print(summ(2, 3))


# Передача аргументов декораторам

# Декоратор с параметрами
import math
from functools import wraps # ВСТРОЕННЫЙ ДЕКОРАТОР ДЛЯ СОХРАНЕННИЕ ИМЕНИ И ОПИСАНИЯ
#
# # добавляем еще одну вложенную функцию которой сможем передать
# # параметр(ПАРМЕТРЫ) для дикоратора
def df_decorator(dx = 0.00001): # позволяет принять дополнительные параметры дикоратору
    def func_decorator(func): # принимает ссылку на функцию
        @wraps(func) # декоратор для сохранения имени и описания изначальной функции
        def wrapper(x, *args, **kwargs): # принимает параметры функции
            res = (func(x + dx, *args, **kwargs) - func(x, *args, **kwargs)) / dx # выполняет функцию и доп условия
            return res # возврощает результат работы блока wrapper

        return wrapper # возвращает ссылку

    return func_decorator # возвращает ссылку

# # ПЕРЕДАЕМ В ДИКОРАТОР ПАРАМЕТРЫ
@df_decorator(dx=0.01)
def sin_df(x):
    return math.sin(x)
# после декорирования sin_df при обращении к методу
# print(sin_df.___name___) вместо sin_df на экран выведться wrapper
# т.е. имя будет потерянно
# что бы сохранить имя функции до декорирования sin_df
# в блоке wrapper добавляем строчку wrapper.___name___ = func.___name___
# так же что бы сохранить описание функции после декорирования добавляем строчку
# wrapper.___doc___ = func.___doc___

# ИЛИ ИСПОЛЬЗУЕМ ВСТРОЕННЫЙ ДЕКОРАТОР ДЛЯ СОХРАНЕННИЕ ИМЕНИ И ОПИСАНИЯ
# from functools import wraps подключаем как библиотеку
