Типы данных в Python делятся на две категории:
изменяемые (list, set, dict, ...)
неизменяемые (int, float, bool, tuple, str, ...)


В Python существует два типа изменения:
присвоение переменной нового значения
непосредственное изменение объекта



1) случай nums = [1, 2, 3] + [4]
2) случай nums.append(4)
в первом случае мы изменяем переменную, то есть изменяем то, на какой объект она ссылается.
Во втором случае мы изменяем сам объект, на который может ссылаться любое количество переменных.

Важно понимать, что во время изменения объекта, мы изменяем именно объект, а не переменные.
Другими словами, если какая-либо другая переменная указывает на объект, который мы изменили,
эта переменная также отразит это изменение, но не потому что изменилась переменная,
а потому что изменился объект, на который она ссылается.

Оператор присваивания в Python не создает копию объекта,
он лишь связывает имя переменной с объектом.
Для неизменяемых объектов это обычно не имеет значения, но для работы с изменяемыми
объектами часто требуется создавать реальные копии.


Python по-разному обрабатывает сложение списков с помощью операторов + и +=
nums1 = [1, 2, 3]
nums2 = nums1
nums1 = nums1 + [4, 5]
print(nums1)
print(nums2)
выводит:
[1, 2, 3, 4, 5]
[1, 2, 3]

В данном случае оператор + создал новый список [1, 2, 3, 4, 5],
который был присвоен переменной nums1,
при этом nums2 по-прежнему указывает на старый список [1, 2, 3].
nums1 = [1, 2, 3]
nums2 = nums1
nums1 += [4, 5]
print(nums1)
print(nums2)
выводит:
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
В данном случае оператор += изменил текущий список, и эти изменения также видны в nums2.
По сути, оператор += для списков работает как списочный метод extend().


Считается плохой практикой использование изменяемых типов данных в качестве значений параметров по умолчанию,
так как значение по умолчанию для параметра создается единожды при определении функции (обычно при загрузке модуля)
и становится атрибутом (свойством) функции.
Поэтому если значением по умолчанию является изменяемый объект,
то его изменение повлияет на каждый следующий вызов функции.

def append(element, seq=[]):
    seq.append(element)
    return seq

print(append(10))
print(append(5))
print(append(1))
print(append(3))
выводит:
[10]
[10, 5]
[10, 5, 1]
[10, 5, 1, 3]

Для решения проблемы можно использовать константу None в качестве значения параметра по умолчанию,
а в теле функции устанавливать нужное значение:

def append(element, seq=None):
    if seq is None:
        seq = []
    seq.append(element)
    return seq
print(append(10))
print(append(5))
print(append(1))

[10]
[5]
[1]