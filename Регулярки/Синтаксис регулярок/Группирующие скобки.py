# Если шаблон регулярного выражения обернуть в  круглые скобки (regex) - мы сгруппируем его.
# Такие группы создаются для получения дополнительной информации о них.
#
#  - (regex)
# Обыкновенная скобочная группа.
# Захватывает символы, о которых можно будет получить более подробную информацию.
#
#  - (?P<name>regex)
# Обычная скобочная группа, но вместе с номером ей будет присвоено имя name.
#
#  - (?P<name>regex)(?P=name)
# r"\b(?P<name>[а-я]+)-?(?P=name)\b"
# Скобочная группа с именем позволяет к ней обращаться и искать такой же текст, который она захватила.
#
#
#  - Ссылки на нумерованные группы
# ([a-z]{4})\1
# Ссылаться можно не только на именованные группы, но и на обычные.
# Для этого достаточно использовать синтаксис \1, \2, \3
# Цифра после слеша означает номер группы, к которой вы обращаетесь
#
#
#


# Скобочные выражения
# Если в группе после открывающейся круглой скобки поставить специальные символы
# - можно создать особое скобочное выражение, которое добавит новую функциональность регулярным выражениям.
#
# Comment group
# (?#) - скобочное выражение, позволяющее написать комментарий в регулярном выражении
# r"Слева(?#\d{0,}[02468]) и справа"
# Выражения внутри комментариев игнорируются.
#
# Non-capturing group
# (?:)
# скобочное выражение, которое группирует регулярное выражение,
# но не захватывает в его отдельную группу
# можно использовать, чтобы применять квантификаторы сразу к нескольким символам
# (?:\d.){2} равносильно \d.\d
#
#
# скобочные группы Не захватывают никаких символов.
#
#  - (?=)
# x(?=y) находит x, только если за x следует y
# Проверяет стоит ли переданное выражение после шаблона.
#
#
#  - (?!)
# x(?!y) находит x, только если за x НЕ следует y
# Проверяет что переданное выражение не стоит после шаблона.
#
#  - (?<=)
# (?<=y)x находит x, только если перед x следует y
# Проверяет стоит ли переданное выражение перед шаблоном.
#
#  - (?<!)
# (?<!y)x находит x, только если перед x НЕ следует y
# Проверяет что переданное выражение не стоит перед шаблоном.
#
#
# (?<=\d)test(?=\d)
# ищет слово test среди двух цифр, но не захватывает их

# Ограничение Lookbehind
# Движок регулярных выражений в Python не может работать с выражениями неопределённой длины в Lookbehind
# все выражения в lookbehind должны быть фиксированной ширины,
# иначе вы получите ошибку re.error: look-behind requires fixed-width pattern

# Если нужно проверить несколько вариантов то пишем так:
# r'((?<=№ )|(?<=Номер )|(?<=Number ))\d{3}'
#
# # Вызовут ошибку:
# r'(?<=test{0,})regex'
# r'(?<=g?)regex'
# r'(?<!Python+)regex'
# # Длина вхождений выражений в Lookbehind может быть разной
# # Поэтому появится ошибка
#
# # Ошибки не будет:
# r'(?<=test)regex'
# r'(?<=g{21})regex'
# r'(?<!Pytho[mn])regex'
# # Длина вхождений выражений в Lookbehind фиксированная
# # Всё выполнится без ошибок


# Атомарная группировка
# решение проблемы с catastrophic backtracking - атомарная группировка:
#
# (?>regex)
# Пытается найти вхождения regex, как если бы оно было отдельным регулярным выражением.
# Если совпадения найдены - движок регулярных выражений пытается найти совпадения для оставшейся
# части регулярного выражения, следующего после атомарной группировки.
# Если совпадений нет - движок регулярных выражения может откатиться назад только на место до атомарной группировки.
# С помощью атомарной группировки можно сказать движку, что откатываться в этом месте и искать
# всевозможные пути не имеет смысла: внутри (?>regex) откат запрещён.
# Выражение (?>.*). никогда не найдёт совпадений, потому что шаблон .*
# нашёл бы все возможные символы в тексте, и оставшаяся . не смогла бы найти совпадение.
# x{m,n}+ одно и то же, что и (?>x{m,n})
# x*+ одно и то же, что и (?>x*)
# x++ одно и то же, что и (?>x+)
# x?+ одно и то же, что и (?>x?)