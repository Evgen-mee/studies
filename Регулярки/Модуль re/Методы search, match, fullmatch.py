#  - re.search()
# ищет первое совпадение в строке
# re.search(pattern, string, flags=0)
#
# pattern - регулярное выражение
# string - строка, к которой нужно применить регулярное выражение
# flags - флаг
#
# Возвращаемое значение:
# Объект Match, если совпадение было найдено
# None, если нету совпадений
#
# import re
# pattern = r'\d{3}' # Поиск последовательности из трёх чисел в строке
# string = 'abc 123 def 456 fed 321 cba'
# result = re.search(pattern, string) # Ищет только одно вхождение, самое первое
# print(result) # <re.Match object; span=(4, 7), match='123'>


#  - re.match()
# ищет совпадение в начале строки
# re.match(pattern, string, flags=0)
#
# pattern - регулярное выражение
# string - строка, к которой нужно применить регулярное выражение
# flags - флаг
#
# Возвращаемое значение:
# Объект Match, если совпадение было найдено
# None, если нету совпадений
#
# import re
# pattern = r'\d{3}' # Поиск последовательности из трёх чисел в строке
# string = '123 abc 456 def 654 cba 321'
# result = re.match(pattern, string) # Ищет только одно вхождение в начале строки
# print(result) # <re.Match object; span=(0, 3), match='123'>


#  - fullmatch()
# определяет соответствие строки переданному шаблону.
# Если вся строка соответствует шаблону - выводит объект Match, иначе - None
# re.fullmatch(pattern, string, flags=0)
#
# pattern - регулярное выражение
# string - строка, к которой нужно применить регулярное выражение
# flags - флаг
#
# Возвращаемое значение:
# Объект Match, если вся строка соответствует шаблону
# None, если строка не соответствует шаблону
#
# print(re.fullmatch('\d', '111')) # None
# print(re.fullmatch('\d', '1'))   # <re.Match object; span=(0, 1), match='1'>


#  - finditer()
# возвращает итератор Match объектов с вхождениями pattern в строке string
# re.finditer(pattern, string, flags=0)
#
# pattern - регулярное выражение
# string - строка, к которой нужно применить регулярное выражение
# flags - флаг
#
# Возвращаемое значение:
# Итератор Match объектов
#
# import re
# pattern = r'\d{3}'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.finditer(pattern, string, 0)
# for i in result:
#     print(i)
# будет выведено:
# <re.Match object; span=(4, 7), match='123'>
# <re.Match object; span=(12, 15), match='456'>
# <re.Match object; span=(20, 23), match='321'>


#  - findall()
# возвращает список всех найденных совпадений
# re.findall(pattern, string, flags=0)
# #
# pattern - регулярное выражение
# string - строка, к которой нужно применить регулярное выражение
# flags - флаги
#
# Возвращаемое значение:
# Список совпадений, если они есть
# Пустой список, если совпадений нет
#
# import re
# pattern = r'\d{3}'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.findall(pattern, string)
# print(result) # ['123', '456', '321']


#  - split()
# разбивает строки по заданному паттерну УКАЗЫВАЕМ РАЗДЕЛИТЕЛЬ
# re.split(pattern, string, maxsplit=0, flags=0)
#
# pattern - регулярное выражение
# string - строка, к которой нужно применить регулярное выражение
# maxsplit - максимальное количество делений строки
# flags - флаги
#
# Возвращаемое значение:
# Если совпадения есть - список частей разделённой строки.
# [string], если совпадений нет
#
#
# import re
# pattern = r'\s\d{3}\s'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.split(pattern, string) # Если совпадения есть, то разделит строку на части
# print(result) # ['abc', 'def', 'fed', 'cba']
#
#
# import re
# pattern = r'\s\d{3}\s'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.split(pattern, string, 2)
# передали число в maxsplit что бы разделить строку на нужное колличество
# после указанного деления дальше идет остаток строки
# print(result) # ['abc', 'def', 'fed 321 cba']
#
#
# import re
# pattern = r'123'
# string = '456'
# result = re.split(pattern, string) #Если совпадений нет, то функция вернёт [string]
# print(result) # ['456']


# - sub()
# заменяет найденные вхождения на заданные символы и возвращает исправленную строку.
# re.sub(pattern, replace, string, count=0, flags=0)
#
# pattern - регулярное выражение
# replace - то, на что нужно заменить найденное вхождение
# string - строка, к которой нужно применить регулярное выражение
# count - необязательный аргумент, максимальное число вхождений, подлежащих замене.
# Если этот параметр опущен или равен нулю, то произойдет замена всех вхождений.
# flags - флаги, пройдём позже
#
# Возвращаемое значение:
# Если совпадения есть - изменённая строка
# string, если совпадений нет
#
# import re
# pattern = r'[a-z]{3}'
# replace = '111'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.sub(pattern, replace, string) #Заменяем все трёхбуквенные последовательности на 111
# print(result) # 111 123 111 456 111 321 111
#
# import re
# pattern = r'[a-z]{3}'
# replace = '111'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.sub(pattern, replace, string, 2) #Заменяем первые две трёхбуквенные последовательности на 111
# print(result) # 111 123 111 456 fed 321 cba


#  - subn()
# выполняет ту же операцию, что и функция re.sub(), но возвращает кортеж.
#
# pattern - регулярное выражение
# replace - то, на что нужно заменить найденное вхождение
# string - строка, к которой нужно применить регулярное выражение
# count - необязательный аргумент, максимальное число вхождений, подлежащих замене. Если этот параметр опущен или равен нулю, то произойдет замена всех вхождений.
# flags - флаги, пройдём позже
#
# Возвращаемое значение:
# (Кортеж (new_string, number_of_subs),
# где new_string - новая строка, или старая, если не было совершено замен.
# number_of_subs - количество сделанных замен
#
# import re
# pattern = r'[a-z]{3}'
# replace = '111'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.subn(pattern, replace, string)
# print(result) # ('111 123 111 456 111 321 111', 4)


#  - escape()
# экранирует специальные символы в pattern
# Полезно, если нужно использовать полученную строку как регулярное выражение,
# но в ней могут содержаться спецсимволы.
#
# Если в метод передавать не сырую строку, а обычную - некоторые символы могут экранироваться и
# "потеряться". В итоге вы получите немного не ту строку для регулярного выражения, которую вы ожидали.
#
# pattern - строка, в которой нужно экранировать спецсимволы, чтобы впоследствии использовать в регулярном выражении.
#
# Возвращаемое значение:
# Строка, с экранированными спецсимволами
#
# import re
# print(re.escape(r'https://stepik.org/lesson/694442/step/1?unit=694231'))
# # Выводит https\:\/\/stepik\.org\/lesson\/694442\/step\/1\?unit\=694231