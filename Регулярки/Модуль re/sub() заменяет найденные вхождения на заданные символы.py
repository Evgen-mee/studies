# - sub()
# заменяет найденные вхождения на заданные символы и возвращает исправленную строку.
# re.sub(pattern, replace, string, count=0, flags=0)
#
# pattern - регулярное выражение
# replace - то, на что нужно заменить найденное вхождение
# string - строка, к которой нужно применить регулярное выражение
# count - необязательный аргумент, максимальное число вхождений, подлежащих замене.
# Если этот параметр опущен или равен нулю, то произойдет замена всех вхождений.
# flags - флаги, пройдём позже
#
# Возвращаемое значение:
# Если совпадения есть - изменённая строка
# string, если совпадений нет
#
# import re
# pattern = r'[a-z]{3}'
# replace = '111'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.sub(pattern, replace, string) #Заменяем все трёхбуквенные последовательности на 111
# print(result) # 111 123 111 456 111 321 111
#
# import re
# pattern = r'[a-z]{3}'
# replace = '111'
# string = 'abc 123 def 456 fed 321 cba'
# result = re.sub(pattern, replace, string, 2) #Заменяем первые две трёхбуквенные последовательности на 111
# print(result) # 111 123 111 456 fed 321 cba


# Группы ничего не дают, но их можно использовать в заменах!
# Если в строке, на которую будет происходить замена найденных совпадений написать \n или \g<name>,
# где n это номер группы, а name это имя группы, то они будут заменены на совпадения этих групп:
# import re
# string = "Ненавижу людей, которые пишут дату в формате mm/dd/yyyy. Ну кто пишет 02/22/2022 или 07/13/2022?"
# print(re.sub(r'(\d{2}).(\d{2}).(\d{4})', r'\2.\1.\3', string))
# # Ненавижу людей, которые пишут дату в формате mm/dd/yyyy. Ну кто пишет 22.02.2022 или 13.07.2022?
#
# Заменить несколько вариантов слов на несколько вариантов исправлений!!!
# import re
# pattern = r'([Ее]го|[Ее]ё|[Ии]х)\w+' # ищет все совпадения в строке
# replace = r'\1'                      # Заменяет на верные слова
# string = input()
# result = re.sub(pattern, replace, string,)
# print(result)


# Функции
# НУЖНО ВОЗВРАЩАТЬ STR()!!!!
# НУЖНО ОБРАЩАТЬСЯ К НУЛЕВОЙ ГРУППЕ lambda m: str(len(m[0]))
#
# Можно использовать как и лямбда-функции, так и обычные.
# Вместо строки, на которую нужно заменить вхождение,
# можно передать функцию, которая будет генерировать ту самую строку.
#
# В функцию передаётся Match объект, и теперь мы можем получать доступ к группам,
# а также как-либо изменять и обрабатывать эти данные.
#
# import re
#
# def func(m): # Получаю Match объект в функции.
#     return str(len(m[0]))
#     # Из него беру нулевую группу - т.е. всё, что захватило регулярное выражение.
#     # Получаю её длину, конвертирую в строку, и возвращаю значение.
#
# regex = r'[a-zA-Z]{1,}'
# text = 'Lorem Ipsum is simply dummy text of the printing and typesetting industry.'
#
# res_func = re.sub(regex, func, text)
# res_lambda = re.sub(regex, lambda m: str(len(m[0])), text)
#
# print(res_func)  # 5 5 2 6 5 4 2 3 8 3 11 8.
# print(res_func == res_lambda)  # True

# import re
# regex = r'\b\d+\b'
# text = input()
# res_lambda = re.sub(regex, lambda m: (str(int(m[0]) // 3) if int(m[0]) % 3 == 0 else m[0]), text)
# print(res_lambda)