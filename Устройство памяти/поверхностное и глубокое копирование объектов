Модуль copy содержит две функции:
- copy(): копирует объект и возвращает его поверхностную копию
- deepcopy(): копирует объект и возвращает его глубокую копию

Поверхностное копирование создает отдельный новый объект,
но вместо копирования дочерних элементов в новый объект,
оно просто копирует ссылки на их адреса памяти.



import copy
data1 = [1, 2, 3]
data2 = copy.copy(data1)
data1.append(4)

print(id(data1), data1) == 2072210867584 [1, 2, 3, 4]
print(id(data2), data2) == 2072250543808 [1, 2, 3]

Поверхностное копирование создает отдельный новый объект,
но вместо того чтобы копировать дочерние элементы в новый объект,
оно просто копирует ссылки на их адреса памяти.

Глубокое копирование создает новую и отдельную
копию всего объекта со своим уникальным адресом памяти.
Это означает, что любые изменения, внесенные вами в новую копию объекта,
не будут отражаться в исходной, и наоборот.

import copy
data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.deepcopy(data1)
data1[0].append(7)
data2[1].append(8)
print(id(data1), data1) == 2001097388608 [[1, 2, 3, 7], [4, 5, 6]]
print(id(data2), data2) == 2001108045760 [[1, 2, 3], [4, 5, 6, 8]]
При глубоком копировании временные затраты на создание копии, очевидно выше чем при создании поверхностной копии.
Если копируемый объект имеет сложную вложенную структуру, то глубокое копирование может тратить много времени.


У списков, множеств и словарей есть метод copy(), создающий их поверхностную копию
data1 = [1, 2, 3, 4]
data2 = [[1, 2], [3, 4]]
new_data1 = data1.copy()
new_data2 = data2.copy()
print(data1 is new_data1, data1 == new_data1)
print(data2 is new_data2, data2 == new_data2)
new_data1[0] = 100
new_data2[0][0] = 100
print(data1)
print(data2)
выводит:
False True
False True
[1, 2, 3, 4]
[[100, 2], [3, 4]]

Поверхностную копию списка также можно создать с помощью среза всего списка.


