# iterable (итерируемый) — это свойство того, по кому будет происходить итерирование
# iterator (итерирующий) — это тот, кто ходит
#
# Единственное, что мы можем сделать с итератором, — передать его функции next().
# Как только итератор становится пустым и порождается исключение StopIteration,
# он становится совершенно бесполезным.
#
# range являются ленивыми, преобразовывать их в списки стоит с особенной аккуратностью
#
# коллекции не являются итераторами
# нужно создавать итератор из коллекции
# nums = [1, 2, 3, 4]
# nums_iterator = iter(nums)       # создаем итератор
# print(type(nums))                # <class 'list'>
# print(type(nums_iterator))       # <class 'list_iterator'>
# print(next(nums_iterator))       # 1
# print(next(nums_iterator))       # 2
#
# функция len() не применима к итераторам
#
# numbers = [1, 2, 3]
# name = 'python'
# for num in numbers:        # итерируем по списку, перебирая каждый элемент
#     print(num)
# for c in name:             # итерируем по строке, перебирая каждый символ
#     print(c)
# print(2 in numbers)        # неявное итерирование по списку
# print('A' in name)         # неявное итерирование по строке
# print(*numbers)            # неявное итерирование по списку при распаковке
#
# в Python, существует два типа итерируемых объектов:
#  - итераторы
# Итератор — специальный объект, который выдает свои элементы по одному за раз.
# сли же в итераторе элементов больше не осталось, то вызов функции next()
# приведет к возникновению исключения StopIteration.
#
#  - коллекции и последовательности
# Коллекции не являются итераторами сами по себе,
# но позволяют создать итератор на своей основе.
# Для того чтобы создать итератор на основе некоторой коллекции:
# numbers = [1, 2, 3]
# iterator = iter(numbers)          # создаем итератор на основании списка
# print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
# print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
# print(next(iterator))             # запрашиваем и печатаем третий элемент итератора
# print(next(iterator))             # возбуждается исключение StopIteration
#
# разница между последовательностями и итераторами
#  - в последовательностях элементы пронумерованы индексами, начиная от нуля
# можем обратиться к конкретному элементу таких объектов по индексу
#
#  - В итераторах мы можем лишь последовательно запрашивать следующий элемент.
#
# Основными преимуществами итераторов:
#
#  - однотипность работы с объектами разных типов
# По сути, приведенный ниже код:
# numbers = [1, 2, 3, 4]
# for num in numbers:
#     print(num)
# за кулисами превращается в:
# numbers = [1, 2, 3, 4]
# iterator = iter(numbers)           # создается итератор
# while True:
#     try:
#         item = next(iterator)
#         print(item)
#     except StopIteration:
#         break
#
#
#  - ленивые вычисления и экономия потребляемой памяти
# numbers = range(5)             # 5 чисел в последовательности
# for num in numbers:
#     print(num)
#
# объект типа range не хранит весь набор чисел
# оздает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся
# Размер объектов range не зависит от количества, нужно помнить только начальное и конечное значения последовательности
# Все объекты range 48 байт
#
# from sys import getsizeof
# numbers1 = range(5)                  # 5 чисел в последовательности
# numbers2 = range(100000)             # 100000 чисел в последовательности
# numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности
# print(getsizeof(numbers1))           # 48 байт
# print(getsizeof(numbers2))           # 48 байт
# print(getsizeof(numbers3))           # 48 байт
#
# мы можем преобразовать любой итерируемый объект в список
#
# from sys import getsizeof
# numbers1 = list(range(5))                  # 5 чисел в списке
# numbers2 = list(range(100000))             # 100000 чисел в списке
# print(getsizeof(numbers1))                 # 96 байт
# print(getsizeof(numbers2))                 # 800056 байт
#
#
#  - комбинация множества итераторов для создания понятной и читабельной программы
# итераторы можно комбинировать
# sentence = 'In the face of ambiguity refuse the temptation to guess'
# filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
# map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
# enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем
#
#
#  - next()
# можно передать второй аргумент
# будет возвращен вместо возбуждения исключения StopIteration
# nums = iter([1, 2, 3, 4])
# print(next(nums))
# print(next(nums))
# print(next(nums))
# print(next(nums))
# print(next(nums, -1))
# print(next(nums, -1))

