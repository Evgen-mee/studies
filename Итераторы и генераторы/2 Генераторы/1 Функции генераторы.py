# Итерируемый объект и итератор – это протоколы, то есть правила реализации.
#
# Генератор – это не протокол, а конкретная реализация


# Функция генератор – это функция, которая возвращает итератор.
# Она выглядит как обычная функция, за исключением того,
# что использует выражение yield, а не return.

# Функция генератор,сохраняет локальные переменные от вызова к вызову.


# порождает последовательность целых чисел от 0 (включительно) до n
# def generate_ints(n):                  # возвращает генератор, порождающий последовательность нужных чисел
#     for num in range(n):
#         yield num


# generator1 = generate_ints(5)           # создаем генератор, порождающий числа 0 1 2 3 4
# print(type(generator1))                 # <class 'generator'>
# print(next(generator1))                 # 0
# print(next(generator1))                 # 1
# print(next(generator1))                 # 2
# print(next(generator1))                 # 3
# print(next(generator1))                 # 4
# generator2 = generate_ints(3)           # создаем генератор, порождающий числа 0 1 2
# for num in generator2:
#     print(num)
# num1, num2 = generate_ints(2)           # создаем генератор, порождающий числа 0 1


# Генератор – это итератор, который порождает значения, переданные yield
# Когда выполнение доходит до конца функции, объект генератор возбуждает исключение StopIteration


# Работа с генератором происходит по стандартному сценарию работы с итератором
#  - вызывать функцию next()
#  - итерироваться с помощью цикла for
#  - распаковывать генератор
#  - проверять принадлежность с помощью оператора in


# Функция генератор возвращает объект специального типа <class 'generator'>,
# который реализует протокол итератора, то есть является самым настоящим итератором

# Класс GenerateInts
# class GenerateInts:
#     def __init__(self, n):  # конструктор принимает верхнюю границу диапазона
#         self.n = n          # Верхняя граница
#         self.current = 0    # Счетчик
#
#     def __iter__(self):
#         return self
#
#     def __next__(self):
#         if self.current == self.n: # условие завершение
#             raise StopIteration
#         else:
#             self.current += 1          # увеличили счетчик
#             return self.current - 1    # уменьшили для того что бы вернуть корректное значение



# генераторы с побочными действиями
# Функция генератор может не только порождать значения, но и совершать различные побочные действия
#  - вывод текста на экран
#  - запись данных в файл
#  - приостановка исполняющейся программы на некоторое время
#
# def generate_AB():
#     print('start')
#     yield 'A'
#     print('continue')
#     yield 'B'
#     print('end')
#
# for char in generate_AB():  # for сначала получает итератор (iterator = iter(generate_AB()))
#     print('-->', char) # на каждой итерации печатается строка --> и значение next(iterator)
# выводит:
# start
# --> A
# continue
# --> B
# end


# return в теле функции генератора
# def generate_ints():
#     yield 1
#     yield 2
#     return 3 # возбуждает исключение StopIteration само значение 3 не выводится
#     yield 4
#
# for num in generate_ints(): # перехватывает исключение StopIteration
#     print(num)

# Особенности и ограничения функций генераторов
# особенности, присущие всем функциям генераторам:
#  - любая функция, содержащая ключевое слово yield, является функцией генератором
#  - когда вызывается функция генератор, то она не возвращает единственное значение
#  - функция генератор всегда возвращает объект типа generator


# Разница между yield и оператором return:
# состояние выполнения генератора приостанавливается и локальные переменные сохраняются
# При следующем вызове метода генератора __next__() функция возобновляет
# свое выполнение из той точки, из которой завершила в прошлый раз.


# Генератор является итератором, поэтому он обладает всеми его особенностями:
#  - нельзя получить длину генератора функцией len()
#  - нельзя распечатать элементы генератора функцией print() без предварительной распаковки
#  - у генератора нельзя получить элемент по индексу
#  - после итерации по генератору он становится пустым





