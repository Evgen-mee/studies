# Система контроля версий
# это программное обеспечение, позволяющее хранить все изменения, которые мы когда-либо вносили в проект

# позволяет хранить несколько версий одного и того же документа
# и при необходимости возвращаться к более ранним версиям
# определять кто и когда сделал то или иное изменение


#Виды систем контроля версий

#репозиторий - хранилище с кодом, если кратко;

#коммит - фиксация изменений (снимок) или конкретная версия репозитория)

#ветка (брэнч) – альтернативная реальность кода, история которого начинается от конкретного коммита.

#Системы контроля версий бывают

# централизованные - один-единственный сервер (репозиторий), содержащий всю историю проекта, все версии изменений.
# То есть, обмен изменениями происходит только с сервером.

# распределенные - у каждого разработчика есть копия всего репозитория,
# которая является полным бэкапом (резервной копией) данных.
# Копии легко создавать, все они являются равноправным и могут синхронизироваться между собой


# Git представляет собой каталог файловой системы,
# в котором находятся файлы конфигурации репозитория, файлы журналов, хранящие операции,
# выполняемые над репозиторием, индекс, описывающий расположение файлов, и хранилище этих файлов.
# А по-простому репозиторий – это хранилище данных)).

# Git отличается особым подходом к обработке информации:
# он не записывает отдельно внесенные правки,
# а делает подробный снимок проекта (snapshot (снэпшот)) в момент сохранения
# Он фиксирует состояние каждого файла, и создает ссылку на эту версию.


# Git нужен для:
# Хранить, обрабатывать и передавать данные: можем работать с контентом

# Контролировать изменения проекта: Git создает свою базу изменений,
# и мы можем в любой момент откатиться в прошлое до поломки кода.

# Вести параллельную разработку: одни и те же объекты можем редактировать как мы, так и другие участники команды,
# причем никаких конфликтов при этом не будет.
# Ведь каждый хранит свои правки в локальном репозитории на своем компьютере.
# Они не вступят в силу, пока мы их не выгрузим на сервер и не сольем с основной версией.


#Как работает Git?

#Remote repository – удаленный репозиторий, удаленное хранилище данных.

# Master branch – главная ветка, "золотая" ветка, содержащая эталонный код.
# Ее также называют origin master.

# Commit – тот самый коммит – зафиксированное состояние проекта в определенный момент времени;
# контрольная точка на ветке изменений проекта.

# 1. Создаем у себя копию удаленного репозитория с копией золотой ветки проекта

# 2. Начинаем работать в этой копии (на локальной ветке). Пишем код, изменяем его.

# 3. Фиксируем (коммитим) все, что сделали, если хотим поделиться нашим творением
# – пушим его на удаленный репозиторий. Если не хотим – не пушим)).
# Закрыли все, выключили компьютер.

# 4. Решили снова поработать – сначала обновляем нашу локальную ветку до состояния master branch.
# Для этого командой git pull стягиваем к себе все, что другие запушили в удаленный репозиторий.
# Наши творения никуда не денутся, они так же лежат на нашей локальной ветке,
# можем продолжать с ними работать, не забывая коммитить.

# 5. Если нам нужно разработать какой-то новый функционал, то создаем новую ветку под него и работаем в ней.
# Поработали, закоммитили, посмотрели, что у нас есть две ветки, одна из которых (main) является условно основной.
# Переключаемся на нее и добавляем этот функционал (делаем слияние веток)

# Строение Git

# working directory – рабочий каталог,  каталог проекта, в котором содержится папка .git,
# рабочая копия определенной версии проекта

# stage (staging area) = индекс — специальная промежуточная область,
# в которой хранится информация о том, что должно войти в следующий коммит

# каталог Git = Git repository = репозиторий Git = Git directory — локальный репозиторий гита

# Все принадлежащие гиту файлы проходят через несколько секций хранилища:
# рабочий каталог (working directory),
# область/стадия подготовленных файлов или индекс (staging area, "стейджинг-зона")
# и git-каталог (git directory).

# Наши файлы путешествуют между этими тремя областями.
# Файлы, с которыми мы работаем напрямую – это working directory.
# Что-то изменили в этих файлах – изменилось состояние рабочего каталога.

# Рабочий каталог (working directory) — это каталог нашего проекта, сжатая база данных.

# Стадия подготовленных файлов (индекс) — это промежуточная область между двумя каталогами,
# куда мы будем добавлять файлы, которые будут переданы в репозиторий Git для отслеживания их версий.

# git-каталог — это и есть локальный репозиторий Git, который был клонирован с сервера.
# Это самая важная часть системы: именно тут хранятся все объекты и данные нашего проекта
# (и их версии): код, изображения, файлы конфигурации, скрипты, стили.
# Этот репозиторий мы потом и будем пушить на сервер.


#Внутреннее устройство Git. Объекты.

# Всю информацию Git представляет в виде своих "объектов" – специальных файлов,
# содержащих определенную информацию о репозитории с его файлами.
# Все объекты хранятся в папке .git/objects/  и являются git-объектами одного из 4-х разных типов:
# "блоб", "дерево", "коммит" или "таг".

# blob-файл — начальное представление данных в Git — один файл на единицу хранения.
# Он формируется для каждого файла в репозитории и содержит его имя и сжатое содержимое.
# Блоб-файл просто хранит снимок содержимого файла, он формируется, когда мы добавляем файл в индекс.

# "дерево" (tree) – содержит одну или более записей, указывающей на другое дерево или на blob-объект.
# Это что-то вроде директории, которая показывает связи между файлами в репозитории.
# Оно ссылается на группу других деревьев и блобов, показывает, какие файлы и папки лежат в данной директории.
# Объект дерево формируется для каждой папки репозитория во время коммита и состоит из имен блоб-объектов
# (для файлов, которые лежат в данной папке) и других деревьев для всех поддиректорий.
# Если blob-объекты хранят информацию о файлах репозитория и их содержимом,
# то tree-объекты хранят информацию о расположении этих файлов в репозитории.

# "коммит" – это объект, который указывает на отдельное дерево,
# фиксируя в истории каким образом оно выглядит в момент выполнения коммита.
# Он содержит мета информацию: имя автора коммита, время коммита, указатель на предыдущий коммит
# и tree-объект корневой директории проекта.

# "таг" — это способ маркировать (дать какое либо легко запоминающееся имя) определенный
# коммит как специфический, чтобы впоследствии было легче его найти.


# Имена объектов в индексе

# Для обеспечения целостности данных Git использует специальные имена — SHA-1 хэши.
# Это контрольная хэш-сумма содержимого и заголовка объекта, уникальный идентификатор для каждого объекта

# Каждому blob-объекту Git присваивает имя — SHA-1 хэш. Эта 40-значная строка и будет
# единицей хранения файла в репозитории гита.
# Первые два символа SHA определяют подкаталог файла, остальные 38 — имя

# Итак, простое добавление файла в Git приводит к сохранению его содержимого в папке objects.
# И это добавление будет храниться там, даже если мы удалим сам файл из рабочей копии.


# Настройка Git

# Системные распространяются на всех пользователей, а файл с такими настройками хранится в:
# C:\Program Files\Git\etc\gitconfig для Windows и /etc/gitconfig для Linux/MacOS.

# Глобальные настройки одинаковы для всех репозиториев, созданных конкретно нами, файл с ними хранится в:
# C:/User/<имя пользователя>/.gitconfig в Windows и ~ /.gitconfig для Linux/MacOS.

# Локальные настройки (на уровне репозитория) не применяются к другим нашим проектам.
# Они хранятся в каждом нашем репозитории по адресу: .git/config

# Изменить настройки Git можно, отредактировать файл config(на уровне системы) или .gitconfig(глобально)
# или .git/config(на уровне репозитория) в текстовом редакторе
# или В терминале вводим команду, которая глобально задаст наше имя



# создать ЛОКАЛЬНЫЙ Git-репозиторий

# создать (инициализировать) новый
# 1) на своем компьютере создаем папку будущего проекта, переходим в нее и
# инициализируем репозиторий в ней с помощью команды
# git init .. Точка после пробела в конце команды обязательна.
# Для начала создадим в терминале папку my-project и зайдем в нее с помощью команды cd my-project
# Для того, чтобы подключить гит, нужно создать базу данных
# для него с помощью команды с точкой через пробел в конце git init .
# Это создаст на базе текущей папки my-project новый подкаталог
# .git (репозиторий Git), в котором и будет содержаться вся конфигурация Git и история проекта.
# Точка после команды говорит о том, что именно в этой папке, где мы сейчас находимся (my-project),
# и будет база данных git.

# 2) репозиторий готов к работе: можем добавлять в него свои файлы, редактировать их, удалять и т.д.

# 3) после этого делаем коммит изменений, который говорит,
# что теперь новые файлы готовы к отправке в удаленный репозиторий

# 4) связываем локальный и удаленный репозитории с помощью определенной команды,
# которая дает Git'у знать, где находится удаленный сервер (куда отправлять файлы)

# 5) отправляем данные в удаленный репозиторий используем команду git push.

# Если мы хотим использовать Git для уже имеющегося у нас проекта, делаем все то же самое, открыв нужный каталог.

# клонировать уже существующий
# мы хотим скопировать репозиторий из удаленного хранилища (например, GitHub).
# Мы будем клонировать себе его копию, выполним команду git clone с указанием ссылки на удаленный репозиторий.




# Как посмотреть информацию о статусе файлов, находящихся в репозитории

# Задав команду git status , мы увидим, что в папке my-project пока ничего не было сделано:
# Так как наш репозиторий пока пустой – в нем нет никаких измененных файлов – создадим в нем файл file1.txt
# с каким-то текстом, например, "Source file1" с помощью команды echo:

# Теперь зададим команду git status и посмотрим, как поведет себя гит:

# гит увидел новый для него файл, подсветил его красным цветом и определил, что он – Untracked.
# В данном состоянии Git просто знает об этом файле в проекте,  но еще не отслеживает его изменения
# Git не следит за изменениями в таких файлах, потому что эти изменения не добавлены в репозиторий.

# Чтобы отслеживать файл, мы должны его зафиксировать (сделать коммит).
# Но прежде чем зафиксировать, нам надо подготовить его к фиксации
# — отправить его в промежуточную область — Stage
# (Staging area, Индекс, стадия подготовленных файлов).



# Что такое Stage/Staging area

# Stage ("стейдж") — стадия/область подготовленных файлов, в it-терминологии называется индексом.
# Технически это просто файлик, содержащий имена файлов и изменения в них, которые должны войти в следующий коммит.

# Для добавления файла в Stage используется команда git add,
# а сам процесс добавления файлов в промежуточную область называется индексацией

# Индекс — промежуточное место между нашим прошлым коммитом и следующим.
# Мы можем добавлять или удалять файлы из индекса, а можем просто просмотреть индекс с помощью команды git status.

# когда разработчик работает пусть даже над одной задачей, то выполняя ее,
# он вместе с тем исправляет и разные недочеты в коде
# В итоге в рабочей директории появляется много разных исправлений, которые частично относятся к выполняемой задаче
# а частично содержат исправления, напрямую не связанные с основными изменениями
# И если делать ровно один коммит, включающий в себя и основную задачу, и дополнительные исправления
# то будем иметь неприятные побочные эффекты

# 1)сложнее смотреть историю ведь коммит начинает содержать совершенно несвязанные изменения
# 2)откат коммита по любым причинам приведет к тому, что откатятся правки, которые все равно нужно будет делать

# Именно здесь помогает индекс: он позволяет меньше переживать на тему того, как сформируется коммит

# С помощью индексации гиту не приходится отслеживать все файлы в проекте, т.к.
# некоторые файлы (например, файлы классов, файлы журналов, файлы результатов, временные файлы данных)
# создаются динамически, и отслеживать их версии просто бессмысленно.
# А вот созданные нами артефакты проекта — файлы исходного кода, файлы данных, файлы конфигурации и другие
# — содержат бизнес-логику приложения.
# Они должны отслеживаться гитом, поэтому мы их обязательно добавляем в промежуточную область

# Стандартный способ работы с индексом — это добавление или изменение файлов и последующий коммит

# добавим наш файл file1.txt в индекс с помощью git add C этого момента Git начинает его отслеживать

# Важно! Если мы что-то изменили в файле, но не сделали для него git add, то он не войдет в текущий коммит.
# В коммите будет только старая версия файла (до изменений), если таковая имеется.



# Что такое коммит

# Коммит — фиксация изменений, внесенных в индекс. Т.е мы всегда сначала добавляем файл с помощью
# git add в индекс и только потом делаем коммит — снимок текущего состояния изменений, добавленных в индекс.

# Еще говорят, что коммит — это единица изменений в проекте. Коммиты можно рассматривать как "безопасные"
# версии проекта — Git не будет их менять, пока мы явным образом не попросим об этом.

# Команда git commit делает коммит. Каждый коммит имеет:
# - хэш, например, 549892a096...2184cf57f7 – это уникальный идентификатор коммита,
# который позволяет в любое время к нему откатиться
# - сообщение, например "Added Работа с файлами" (commit message говорит, ЧТО делает коммит, а не КАК делает)
# - все индексированные файлы репозитория
# - изменения по каждому файлу
# - имя автора и время создания коммита.

# Команда git commit берет все данные, добавленные в индекс с помощью git add,
# и сохраняет их снимок во внутренней базе данных.

# Вернемся к нашему файлу. Мы его создали, добавили в индекс, осталось его "закоммитить"  командой:
# git commit и оставить небольшое описание в кавычках (одинарных или двойных — не важно, важно оставить комментарий).
# Комментарий оставляем обязательно, т.к. сделать коммит без него не получится:
# git commit -m 'my first commit, this is Version 1.0'

# сделать коммит — это значит сделать изменения, собрать эти изменения командой git add
# и указать коммит-сообщение после ключа -m (расшифровывается как "message").
# Кстати, старайтесь сразу писать правильные комментарии после  ключа -m:
# по вашему комментарию к коммиту должно было понять, какие изменения были сделаны.
# Это также должно помочь новым участникам проекта лучше понять смысл коммитов:
# надо знать, зачем человек его сделал и какие последствия это вызовет.

# Теперь нам останется только запушить наши результаты командой git push на удаленный сервер,
# чтобы другие разработчики тоже имели к ним доступ.



# Статусы (состояния) файла в Git
# untracked — неотслеживаемый гитом файл
#
# unmodified — неизмененный отслеживаемый гитом файл
#
# modified — измененный отслеживаемый гитом файл
#
# staged — подготовленный к коммиту отслеживаемый гитом файл
#
#
# Каждый файл в рабочем каталоге находится в одном из двух состояний:
#
# 1) Отслеживаемые файлы - это те файлы, для которых был сделан коммит
# (он зафиксирован, для него есть последний снимок состояния в проекте).
# Они могут быть неизмененными, измененными или подготовленными к коммиту.
#
# 2) Неотслеживаемые файлы - это любые файлы в рабочем каталоге,
# которым еще не делался коммит и еще не подготовлены к коммиту.
#
# Состояние Untracked имеют все неотслеживаемые файлы и директории.
# Отслеживаемые файлы, как уже было сказано выше, могут находится в 3 состояниях:
# неизмененный отслеживаемый (Unmodified),
# измененный отслеживаемый (Modified)
# и подготовленный для фиксации в коммит (Staged).
#
# Когда мы с помощью команды git add добавляем неотслеживаемый файл,
# то он переходит в состояние Staged и начинает отслеживаться гитом:
#
# Untracked     >    Staged
#
# Если у нас файл уже отслеживается гитом (в состоянии Unmodified) и мы его изменяем — добавляем строчки,
# удаляем что-то и т.д. — то он переходит в состояние "измененный отслеживаемый":
#
# Unmodified   >   Modified
#
# В этом состоянии Git продолжает осуществлять контроль над всеми сделанными в этом файле изменениями,
# просто файл не будет добавлен в следующий коммит.
# Статус Modified показывает, что файл имеет историю в системе Git
# и был изменен относительно его последнего состояния.
# Если мы теперь сохраним наш измененный файл, то он переходит в состояние Staged:
#
# Modified    >    Staged
#
# Если мы делаем коммит файла, который находится в состоянии Staged,
# он переходит в состояние Unmodified (неизмененный отслеживаемый):
#
# Staged    >   Unmodified
#
# Весь цикл можно представить следующим образом:
# мы изменяем файл, сохраняем его в индексе и делаем коммит,
# а потом все сначала
#
# Unmodified    >   Modified   >   Staged    >   Unmodified


# Зачем и как мы добавляем файл в .gitignore
#
# На любом проекте в рабочей директории всегда есть файлы и папки,
# которые мы не только не хотим автоматически добавлять в репозиторий,
# но и видеть в списках неотслеживаемых. Обычно к таковым относятся автоматически генерируемые файлы:
# различные логи, результаты сборки программ и т.п., которые постоянно изменяются. Если добавлять их в репозиторий,
# то в коммите будут не только изменения исходного кода, но и изменения в этих файлах в придачу,
# и читать историю таких коммитов будет трудновато.
#
# Поэтому в Git можно с помощью текстового редактора создать специальный игнорируемый файл .gitignore.
# В нем мы вручную перечислим шаблоны, соответствующие таким файлам, а также файлы,
# которые по какой-либо иной причине не должны попадать в коммиты. Этот файл Git помечает для себя как файл,
# который необходимо игнорировать.
#
# Хорошей практикой считается настройка файла .gitignore до того, как начать серьезно работать,
# — это защитит от случайного добавления в репозиторий файлов, которых мы там видеть не хотим.
#
# К шаблонам в файле .gitignore применяются следующие правила:
#
# - пустые строки, а также строки, начинающиеся с #, игнорируются
#
# - можно использовать стандартные glob шаблоны,
# информацию о них можно посмотреть в конце или погуглить самостоятельно
#
# - можно заканчивать шаблон символом слэша (/) для указания каталога
#
# - можно инвертировать шаблон, использовав восклицательный знак
# (!) в качестве первого символа.
#
# Каждый игнорируемый файл указывается в отдельной строке.
# Git будет полностью игнорировать эти файлы, поместив пути к ним в .gitignore.
#
#
# О glob-шаблонах кратко:
# Они представляют собой упрощенные регулярные выражения, используемые командными интерпретаторами:
#
# - символ * соответствует 0 или более символам;
#
# - последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c);
#
# - знак вопроса ? соответствует одному символу;
#
# - квадратные скобки, в которые заключены символы через дефис [0-9],
# соответствуют любому символу из интервала (в данном случае от 0 до 9).
#
# Также можно использовать две звездочки, чтобы указать на вложенные каталоги:
# a/**/z соответствует a/z, a/b/z, a/b/c/z, и так далее.







