#
#
#
# 0. Итак, мы создали файл (например текстовый) и для того, что бы гит его физически мог отслеживать,
# мы должны поместить его в директорию с git-проектом.
# До этого момента мы не может осуществлять с ним никакие действия на уровне git-a.
# Поместили файл в проект, переходим на сл-щий уровень.
#
# 1. Файл сразу преобретает статус в гите "неотслеживаемого".
# Такой файл может лежать в локальном репозитории проекта, но Гит просто констатирует,
# что вот в проекте есть какой-то файл, но я за ним не слижу.
# Что бы перевести файл из состояния неотслеживаемый в отслеживаемый надо выполнить команду git add filename.
# После этого он переходит в категорию индексированных файлов (находящихся в staged area).
#
# 2.  Отслеживаемый, индексированный (в STAGED статусе, он же по русски - "постановленный" (на учёт)).
# Как только команда add filename была выполнена, сразу создаётся файл в БД гита в директории \objects,
# в котором прикапывается этот файл с именем/директории в виде уникального Хэша.
# Поскольку в нашем новом файле после команды add_file небыло никаких изменений,
# он является готовым к выполнению по нему первого коммита.
# Но делать мы этого пока не будем, лучше мы пока его поредактируем.
# Если это сделаем он получит новый статус - Modified.
# При этом по новым файлам есть особенность - они в этом случае не утрачивают и статус STAGED (почему- об этом ниже)
#
# 3. Отслеживаемый Modified-статус. Как только начинаем вносить изменения в файл
# , но при этом не сохраняем эти изменения на диске- для Гита они не видны
# (так как он сканирует постоянную память, а не ОЗУ),
# т.е. мы вроде видим на экране измененный файл, но для гита он всё еще не измененный.
# Modified статус он приобретает, когда мы вносим какие-то изменения и нажимаем "Сохранить".
# Данный статус подразумевает, что файл изменился, но в будущий коммит пока не эти изменения включены не будет,
# так как файл с этими имзенениями не находится в Staged статусе.
# Для того что бы включить последние изменения в следующий коммит надо выполнить комманду git add filename,
# которую мы уже один раз применяли к этому файлу, когда он был еще в статусе "неотслеживаемый".
# В результате исполнения этой команды файл с последними изменениями перейдет в Staged статус, т.е. готовый к коммиту.
#
# 4. Теперь мы готовы сформировать коммит, т.е. получить полный срез всех отслеживаемых файлов,
# находящихся в staged состоянии. Перед коммитом рассмотрим несколько кейсов:
#
# 1. Если какой-то файл на момент коммита находится в состоянии modified,
# но при этом он присутствует в более ранних коммитах
# (т.е. старый файл, по которому есть изменения, но он не готов к коммиту).
# При выполнении коммита умный гит не будет непосредственно включать этот файл в новый коммит,
# он просто будет понимать, что этот файл надо использовать из более старого коммита, так как он не менялся.
# В дальнейшем, если мы по этому файлу выполним git add, то все наши изменения попадут в новый коммит.
#
# 2. Если какой-то старый файл вообще не менялся, но он отслеживался.
# Тут логика аналогична кейсу 1. Т.е. гит будет ссылаться в текущем коммите на более старый коммит.
#
# 3. У нас новый файл, т.е. в более ранних коммитах его нет.
# При этом он модифицировался, но при этом git add после изменений небыло выполнено.
# В этом случае будет использовано то состояние, которое он имел при добавлении его в staged
# область при переходе из статуса неотслеживаемый в отслеживаемый (этап 1-2)
#
# 4. Неотслеживаемые файлы. Они просто лежат, гиту на них побоку. Никих действий не осуществляется
#
# 5. Отслеживаемые, измененные и готовые к комиту.
# Вот ради них коммит то в первую очередь и делается.
# Гит создает новый срез именно этих дата файлов, фиксируя их в своей БД.


# 1. Чтобы сделать файл отслеживаемым, используем команду git add
#
# 2. Когда мы делаем файл отслеживаемым, происходит следующее:
#
#    2.1. Создается блоб-объект для этого файла с именем – 40-символьным хэшем содержимого файла,
# причем его первые две буквы называют подпапку в папке .git/objects, а остальные 38 – сам файл.
# Такое разделение имени ускоряет поиск blob-файла среди других.
#
#    2.2. Имя этого blob-файла записывается в индекс и с этого момента GIt считает файл подготовленным к коммиту.
#
# 3. Если мы поменяем содержимое файла, нам нужно снова добавить его в индекс.
#
# 4. Индекс — промежуточное место между нашим прошлым коммитом и следующим.
# Мы можем добавлять или удалять файлы из индекса, а также просмотреть индекс с помощью git status.
#
# 5. Команда git status показывает, на каком этапе мы сейчас находимся
#
# 6. Коммиты создаются с помощью команды git commit, которая делает снимок состояния проекта на
# текущий момент времени. Коммиты снимков состояния Git всегда выполняются в локальный репозиторий.