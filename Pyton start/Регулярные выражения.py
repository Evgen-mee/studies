# import re
import re

# символы языка регулярных выражений \.^$+*{}[]()|
# если ищем данные символы (даже есле они часть строки) то
# перед ними ставим "\(\)" пример поиска скобок


# Проверка фрагмента текста по заданному шаблону
# Поиск подстрок по укуказанному шаблону в тексте
# Поиск и замена регулярного выражения на заданную строку
# Разбиение строки по найденным шаблонам

#  литералы и символьный класс
# метод x = re.findall("искомая строка","строка в которой ищем")
# скопирвует все вхождения в переменную x
# x = re.findall("слов","словами, слов словестный, привет")
# на выходе x = [слов, слов, слов, слов]

# если добавить r"\b искомое целое слово\b" то поиск будет только по ЦЕЛЫМ словам
# x = re.findall(r"\bслов\b","словами, слов словестный, привет")
# на выходе x = [слов]

# [] квадратные скобки (регулярное выражение)
# можно писать интервалы
# вместо [0123456789] можно [0-9]
# вместо [abcd и т.д] можно [a-z]
# если хотим искать символ кроме диапозона то [-0-9] дополнительно ищем дефис
# можно инвертировать т.е. сказать не [^0-9] будут считанны все значения кроме цифр
# два интервала и более на один символ [a-zA-z] порядок не важен
# в [] прописываем спецсимволы бес \ .^$+*{}[]()| определяються как символы

# Вместо содержания [] можем использовать символы в которых уже определенно значение

# Вместо re.findall(r"[0123456789]",text)
# используем re.findall(r"[0-9]",text)
# а вместо re.findall(r"[0-9]",text)
# используем  re.findall(r"\d",text)

# . - точка воспринимается как любой символ кроме переноса строки .[]
# \d - любая цифра [0-9]
# \D - любой НЕ цифровой символ [^0-9]
# \s - любой пробельный символ \t \n \r \f \v
# \S - любой НЕ пробельный символ \t \n \r \f \v
# \w - любой символ слова [a-zA-z0-9]
# \W- любой символ НЕ слова [a-zA-z0-9]

# Поиск слова и ЦИФР в разных склонениях падежах и Загллавной строчной
# в [] указали варианты символов
# [eE-вариации первого символа] д - второй символ без вариаций [ауы-вариации третьего символа]
#text = "Еда, беду, еды, победа"
#match = re.findall(r"[eE]д[ауы]",text)
#match = [Еда, еду, еды, еда]  так как ищем не целое слово

#text = "Еда44, беду2, еды1, победа0"
#match = re.findall(r"[0123456789]",text)
#match = [4, 4, 2, 1, 0]  так как ищем посимвольно вернуться только числа а не цифры


# квантификаторы {m,n}, +, * , ?
# re.findall(r"o{2,5}") говорит о том что символ "o" может повторяться от 2 до 5 раз
# x = e.findall(r"o{2,5}","Goooooogl")  Берет значение по максимуму диапозона
# x = ['ooooo']
# x = e.findall(r"o{2,5}","Goooooogl") Берет значение по минимому диапозона (добавили знак ?)
# x = [ 'oo','oo','oo']

# {m} - повторение выражения ровно m раз = {m,m}
# {m,} - повторение выражения oт m и более = {m,",бесконечность"}
# {,n} - повторение не более n раз = {не важно,до n}
# * или {0,} - 0 повторений до бесконечности
# + или {1,} - 1 повторений до бесконечности
# ? = от 0 до 1 {0,1}

# {минимальное число совпадений, максимальное число совпадений}
# text = "Google,Google,Gooooooogle"
# math = re.findall(r"o{2,5}", text)
# math = [oo, ooo, ooooo]

# Проверка номера телефона
#phone = "89102347878"
# match = re.findall(r"8\d{10}",phone)
# 8 - проверка на первый символ \d{10} говорим что следующие 10 цифр должны быть цифрами

# Проверка слова на ошибку
# text = "стеклянный, стекляный" (НЕТ ОДНОЙ Н)
#  match = re.findall(r"стеклянн?ый", text)
# комбинация н? говорит что н не обязательный {0,1}знак может быть может не быть
# match = [стеклянный, стекляный]

# Парсер словаря
# text = "autor=Пушкин А.С.; title = Евгений Онегин; price =200; year= 2001"
# match = re.findall(r("\w+)\s*=\s([^;]]+)", text)
# \w() любой символ слова
# + от 1 и до конца слова
# \s так же могут быть пробелы после слова * от 0 и более (могут быть могут не быть) до
# до знака =
# после знака = \s так же могут быть пробелы после слова * от 0 и более (могут быть могут не быть)
# [^;] выделяем все кроме ;
# match = [(autor,Пушкин А.С.), (title,Евгений Онегин), (price,200), (year,2001)]

# Выделяем тег <img src="bg.jpg">
# text = "<p>Картинка <img src="bg.jpg"> в тексте </p>"
# match = re.findall(r"<img\s+[^>]*?src\s*=\s*[^>]+>", text)
# когда нашли совпадение <img
# \s+ могут идти пробелы до бесконечности
# . добавляем все кроме переноса строки
# [^>]*? пока не встретим хоть раз src
# \s+ могут идти пробелы до бесконечности
# пока не встретим =
# \s+ могут идти пробелы до бесконечности
# # [^>]+ пока не встретим >
# match =["<img src="bg.jpg">"]


#  сохраняющие скобки и группировка
# есле ограничить () то сохраниться то что в скобках
# если нам не надо то что сохраняется в скобках ставим (?:  )
# \1  = ()
# \1 = сохраняющей скобки
# 1 это индекс сохраняющей скобки в строке

# можно вместо обращению по индексу \1
# давать имена сохраняющим скобкам (?P<name>)


# получаем ключ значение
# text = "lat = 5, lon=7, a = 5"
# match = re.findall(r"(?:lat|lon))\s*=\s*\d+", text)
# match = ["lat = 5, lon=7]
# ?: обозначаем что не сохраняемое значение
# (lat|lon) говорим когда встретиться lat или lon
# \s* пробельные символы
# пока не встретиться =
# \s* после = возможно тоже пробельные символы
# \d+ запишем все цифры пока не встретим другой символ

# text = "lat = 5, lon=7, a = 5"
# match = re.findall(r"((lat|lon)\s*=\s*\d+)", text)
# match = [("lat = 5,"lat") ("lon=7","lon")]
# (lat|lon) говорим когда встретиться lat или lon
# вначале записывается найденная фраза lat = 5
# потом после определения соответствия записывается "lat"

# Отдельно ключ отдельно значение
# text = "lat = 5, lon=7, a = 5"
# match = re.findall(r"(lat|lon)\s*=\s*(\d+)", text)
# match = [(lat, 5) (lon, 7)]


# text = "<p>Картинка <img src="bg.jpg"> в тексте </p>"
# match = re.findall(r"<img\s+[^>]*src=[\"'](.+?)[\"']", text)
# match = ["bg.jpg"]
# <img находим тег
# \s+ могут идти пробелы
# [^>] любые символы кроме >
# потом должно быть совпадение src=
# потом должен быть один из символов [\"']
# (.+?) сохраняем любые символы кроме пробела
# потом должен быть один из символов [\"']




# флаги и проверки

# Ищем ЦЕЛОЕ слово из вариантов слов
# text = "подоходный налог"
# match = re.findall(r"\d(прибыль|обретение|доход)\d, text)
# match = None т.к. нет совпадений

# ^ - проверка на начало ТЕКСТА (с флагом re.MULTILINE - начало строки)
# $ - конец текста (с флагом re.MULTILINE - позиция перед символом переноса строки)
# \A - начало текста
# \b - граница слова внутри символьных классов
# \B - граница НЕ слова
# \Z - конец текста
# exp = шаблон
# (?=exp) - проверка на совпадение с exp продолжение строки (опережающая проверка) после набраной строки есть exp
# (?!exp) - проверка на  НЕсовпадение с exp если после набраной строки нет exp
# (?<=exp) - конец набронной строки должен соответствовать exp
# (?>=exp) -  конец набронной строки НЕ должен соответствовать exp

#ПЕРЕСМОТРЕТЬ дописать с  4 видео



# объект re.Match, методы re.search, re.finditer, re.findall

