# Режимы чтения
# 'r' - Read (чтение)
# Открыть файл только для чтения. Такой файл не может быть изменен.

# 'w' - Write (запись)	Открыть файл для записи.
# Если файл уже существует, стереть его содержимое.
# Если файл не существует, он будет создан.

# 'a' - 	Append (добавление)	Открыть файл для записи.
# Данные будут добавлены в конец файла. Если файл не существует, он будет создан.

# 'r+' - Read + Write	Открыть файл для чтения и записи.
# В этом режиме происходит частичная перезапись содержимого файла.

# 'x' - Create (создание)	Создать новый файл.
# Если файл существует, произойдет ошибка.

#По умолчанию режим доступа (второй аргумент функции open()) определен для чтения (литерал 'r'),

# Режим обработки файла указывается после режима доступа к файлу.
# file = open('file.dat', 'rb')
# 't'	Текстовый режим (значение по умолчанию)	Работа с текстовым файлом
# 'b'	Бинарный режим	Работа с бинарными файлами (картинки, звук и т.д.)

# file1 = open(r'C:/Users/temp/test.txt')    # используем прямой слеш / (абсолютный путь)
# file2 = open(r'temp/data.txt')             # используем прямой слеш / (относительный путь)

# чтобы работало на Win и Lun путь пишем так d:/file/file.txt
# используем обратный слеш /

# Функция open. Чтение данных из файла
# open(file,[mode = "r", encoding=None,])
# file - путь
# mode - режим (чтение запись)
# encoding-кодировка файла

# x = open(file.txt, encoding='utf-8') открыли файл на чтение и указали кодировку
# x стала файловой переменной

# метод x.read() читает весь файл
# считывает все содержимое файла, включая переносы строк
# метод x.read("колличество символов для чтения x = 6") читает согласно введенному колличеству символов

# метод x.readline() читает строку до переноса строки \n или до конца файла
# при этом возвращается считанная строка вместе с символом '\n'
# Для удаления символа '\n' из конца считанной строки удобно использовать строковый метод rstrip()
# line = 'Python\n'
# line = line.rstrip()
# что бы при print(x.readline()) не было двойного переноса строки
# делаем print(x.readline(), end ="")
# что бы вывести/прочитать ВЕСЬ ФАЙЛ использум цикл

# метод s = x.readlines() вернет список из строк файла
# каждая строка в списке заканчивается символом переноса строки  '\n'
# не очень подходит для больших файлов тк размер списка будет огромный

# после работы обязательно закрываем файл
# x.close()


# метод seek() - задаёт позицию курсора в байтах от начала файла.
# Чтобы перевести курсор в самое начало файла необходимо вызвать метод seek(),
# передав ему в качестве аргумента значение 0

# Метод seek() не очень полезен при работе с текстовыми файлами, так как не учитывает разделение текста на строки.
# А вот при работе с файлами в двоичном режиме умение работать с позицией и смещениями очень важно!

# метод x.seek(y = 0) будет возвращать указатель на указанный номер символа

# метод x.tell() вернет файловую позицию где сейчас находиться указатель (номер байта)
# utf-8 для русских букв выделяет 2 байта
# когда x.seek == 4(номер символа) то x.tell = 9
# т.к. первый символ файла #FEFF 1(символ файла) + 4(рус символа)*2




# Обработка исключения FileNotFoundError
# try:
#     file = open("мой файл", encoding="utf-8")
#     try: # есле произойдет ошибка чтение файла
#         s = file.readlines()
#         print(s)
#     finally: # файл закроется в любом случае вне зависимости как отработает блок try
#         file.close()
#
# except FileNotFoundError: # отлавливает ошибку открытия
#     print("ошибка открытия")
# except: # отлавливает все остальные ошибки
#     print("Возникла ошибка")

# Менеджер контекста — объект, реализующий одноименный протокол.
# Объекты, реализующие этот протокол, позволяют использовать следующий специальный синтаксис:
# with object as name:
    # Здесь нам доступен ресурс name.
    # Это тело with-блока.
# А здесь ресурс name уже освобождён, даже если в теле with-блока произошла ошибка.

# С помощью менеджера контекста можно работать с несколькими файлами.
# with open('input.txt', 'r') as input_file, open('output.txt', 'w') as output_file:
#     # обработка файлов
#
# Приведенный ниже код:
# file = open('languages.txt', 'r', encoding='utf-8')
# for line in file:
#     print(line)
# file.close()              # ручное закрытие файла
# print('Файл закрыт')
#
# можно переписать в виде:
# with open('languages.txt', 'r', encoding='utf-8') as file:
#     for line in file:
#         print(line)
#                           # автоматическое закрытие файла
# print('Файл закрыт')


# или более правильно использовать менеджер контекста

# try:
#     with open("мой файл", encoding="utf-8") as file: # заменяет блок с длинным кодом выше и В ЛЮБОМ СЛУЧАЕ ЗАКРОЕ ФАЙЛ
#         s = file.readlines()
#         print(s)
#
# except FileNotFoundError: # отлавливает ошибку открытия
#     print("ошибка открытия")
# except: # отлавливает все остальные ошибки
#     print("Возникла ошибка")
# finally:
#     print(file.closed) # после выполнение кода информирвует закрыт или открыт файл


#  Запись данных в файл
# ЕСЛИ ФАЙЛ ОТКРЫТ НА ЗАПИСЬ ТО ЧИТАТЬ ДАННЫЕ С ФАЙЛА ПРИВЕДЕТ К ОШИБКЕ
# ЧТО БЫ ЗАПИСЫВАТЬ И СЧИТЫВАТЬ ИНФОРМАЦИЮ ИСПОЛЬЗУЕМ РЕЖИМ "a+"
# file = open("out.txt", "w") при каждом открытии файл будет перезаписан (предидущей информации не будет)
# file = open("имя файла в который будем записывать", "w - лткрываем файл для записи")
# метов file.write("строка для записи") записывает строку в файл
# закрыли файл file.close()

# есле файл не нашелся то создастся новый в папке с исполняемым файлом

#  метод file.writelines(["новая строка1\n", "новая строка2\n"])  # записали список строк в файл

# try: # в режиме "a" данные будут дописываться в файл в режиме "a+" можно и считать и записать файлы
#     with open("имя файла", "a+" ) as file:
#         # seek только для счтитывания
#         file.seek(0) #переместили головку на первый символ тк по умолчанию указывает на конец файла
#         file.write("новая строка1") #  записали строку  в файл (Запишется в конец файла)
#         file.writelines(["новая строка1", "новая строка2"])  # записали две строки в файл (Запишется в конец файла)
#         s = file.readlines() # создали список из строк файла
#         print(s)
#
# except:
#     print("ошибка работы с файлом")



# БИНАРНЫЙ МЕТОД ЗАПИСИ В ФАЙЛ
# режим "wb" открывает БИНАРНЫЙ файл на запись
# для работы с бинарным файлом подключаем библиотеку import pickle

# import pickle
# # запись данных в файл
# try:
#     with open("нужный файл.bin", "wb") is fale
#         pickle.dump("данные которые записываем в файл", "файл в который записываем")
# except:
#     print("Ошибка файла")
#
# # чтение из файла
# file = open("нужный файл.bin", "rb")
# bs = pickle.load("файл для чтения") # метод чтения бинарного файла
# # в bs лежит список строк (есле вносили строки)
# file.closed()

def swapcase_vowels(string):
    vowels = 'aeiouy'
    swapped_string = ''

    for char in string:
        if char in vowels:
            char.upper()
        swapped_string += char

    return swapped_string