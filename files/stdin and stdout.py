# Взаимодействие файла stdin с функцией input и информацией введенной с клавиатуры.
# Мы присвоили какой-то переменной в программе функцию input.
# Запустили программу.
# Она дошла до нашей переменной и тогда, когда программа обращается к inputу
# input в свою очередь обращается к файлу stdin и файл stdin "говорит":
# пользователь, заполни-ка меня содержимым, чтобы я могла передать эти данные функции input,
# а она в свою очередь передаст их переменной.
# Иными словами происходит следующее взаимодействие между тремя этими сущностями из оглавления и нашей переменной:
# variable --> input() --> файл stdin --> информация введенная с клавиатуры.
# И потом происходит обратный порядок передачи данных:
# информация с клавиатуры записывается в файл stdin,
# данный из stdin передаются в input,
# а последний присваивает их переменной variable.


# Взаимодействие файла stdout с функцией print и консолью вывода.
# Когда наша программа доходит до места,
# в котором есть функция print,
# то она передает свое содержимое в файл stdout,
# а файл stdout стремится все свое содержимое вывести в консоль.
# Мы можем явно, без функции print сделать запись в файл stdout при помощи метода write,
# как это продемонстрировано в уроке,
# и после этого файл stdout сразу себя опустошает напечатав свое содержимое в консоль.
# В данном случае схема такая будет:
# print(data) --[записывает data в файл stdout]--> stdout --[выводит data в консоль]--> консоль

# Подводя итог :
# 1. файл stdin является посредником между вашей программой и функцией input.
# 2. Файл stdout  является посредником между функцией print и консолью.
# 3. Файл stdin "стремится" получить данные с клавиатуры, а файл stdout "стремится" вывести свое соедржимое в консоль.


# Поток ввода (sys.stdin) — является итератором, который невозможно перезапустить.
# Как и любой итератор, он может двигаться только вперёд.
# Как только данные прочитаны, они удаляются из потока ввода безвозвратно.
#
# Элементы, которые выдает этот итератор — это строки, введённые пользователем.
# Если пользовательский ввод закончен, то итератор прекращает работу.
# Пока пользователь не ввёл последнюю строку, мы не знаем, сколько элементов в итераторе.
#
# Чтобы работать с потоком ввода (sys.stdin),
# необходимо подключить модуль sys стандартной командой
# import sys
#
# Для завершения ввода необходимо ввести Ctrl + D
#
# если мы не знаем, в какой момент надо прекратить ввод,
# то воспользоваться функцией input() не удастся.
# В таких случаях остаётся только работать с потоковым вводом (sys.stdin).
#
# Читаем входные данные в одну строку
# С помощью потока ввода (sys.stdin) можно в одну строчку
# кода прочитать весь пользовательский ввод в список
#import sys
# data = [line.strip() for line in sys.stdin]
# или
#data = list(map(str.strip, sys.stdin))

# Методы read() и readlines()
# мы можем обойти циклом for итератор sys.stdin
# readlines()
# можно считать все строки из итератора
# (с сохранением символов перевода строки)
# в список
# import sys
# data = sys.stdin.readlines()  (\n) сохраняется в считанных строках
#
# read()
# считать многострочный текст из стандартного потока ввода в текстовую переменную
# import sys
# data = sys.stdin.read()   (\n) НЕ сохраняется в считанных строках


# потоковый вывод (sys.stdout)
# По умолчанию функция print() перенаправляет вывод данных именно в sys.stdout,
# хотя нам ничего не мешает самостоятельно писать в него.
#
# import sys
# print('Hello')
# sys.stdout.write('world!')
# print('from')
# sys.stdout.write('python\n')
# print('Bye-bye')
# выведет:
# Hello
# world!from
# python
# Bye-bye
#
# функция print() добавляет перевод на новую строку,
# а явная запись данных в sys.stdout с помощью метода write() нет.
# Чтобы добавить перевод на новую строку, мы используем стандартный символ \n.
#
# при использовании потока вывода sys.stdout нам нужно самостоятельно
# преобразовывать данные к строковому типу данных
# (функция print() это делает автоматически).
#
# import sys
# sys.stdout.write(17)
#
# приводит к возникновению ошибки.
# Исправленная версия кода:
#
# import sys
# sys.stdout.write(str(17))     # преобразуем данные в строку
#
# По умолчанию функция input() читает данные из потока ввода sys.stdin,
# а функция print() печатает данные в поток вывода sys.stdout
#
# Функция print() — это удобная обертка (wrapper) вокруг метода sys.stdout.write().
# Функцию input() часто можно рассматривать как обертку (wrapper) вокруг sys.stdin.readline()
#
# объекты sys.stdin и sys.stdout являются файловыми объектами, предоставляемыми ОС.
# Им доступны все соответствующие методы (read(), readline(), readlines(), write(), writelines()).
# В общем случае, когда программа запускается в интерактивном сеансе,
# stdin является клавиатурным вводом,
# а stdout является выводом на экран,
# но оболочка может использоваться для перенаправления из обычных файлов
# или вывода на канал и ввода в другие программы.
#
# import sys
# temp = sys.stdout     #В переменной temp сохраняем исходный потоковый вывод, так как дальше мы его переопределим по другому
# sys.stdout = open('log.txt', 'w')  #переопределяем потоковый вывод на открытие файла для записи
#
# print('testing123')                # print() для вывода использует потоковый sys.stdout, но так как мы его ранее
# print('another line')              # переопределили, то это уже будет не вывод на экран, а запись строки в файл
#
# sys.stdout.close()                 # закрытие файла
# sys.stdout = temp                  # восстанавливаем исходный потоковый вывод из переменной temp
# print('back to normal')            # теперь print() снова будет выводить текст на экран, и эту строку уже не будет записывать в файл
# приведет к созданию текстового файла log.txt, содержащего:
# testing123
# another line