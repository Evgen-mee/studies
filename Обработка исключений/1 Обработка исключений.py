# TypeError возникает, когда встроенная функция (или операция) применяется к объекту неподходящего типа.
# print('beegeek' + 2022) # приводит к возникновению исключения TypeError.

# ValueError возникает, когда встроенная функция (или операция) получает аргумент правильного типа,
# но с неподходящим значением, и ситуация не описывается более точным исключением, например, таким как IndexError.
# num = int('beegeek')  # приводит к возникновению исключения ValueError.


#  - Pass
# может использоваться в качестве заглушки в тех местах, где это синтаксически необходимо, например, в инструкциях,
# где тело является обязательным, таких как def, except, with
# def do_something():
#     pass
#
# try:
#     print('beegeek')
# except:
#     pass
#
# with open('beegeek.txt') as file:
#     pass


# обрабатывают исключения не только в том случае,
# если они возникают непосредственно в блоке try,
# но и в том случае, если они возникают внутри функций, вызываемых в блоке try
# def this_fails():
#     num = 1 / 0
#
# try:
#     this_fails()              # обработает и ошибку в функции this_fails() и вывидет Деление на ноль
# except ZeroDivisionError:
#     print('Деление на ноль')


# Блоки try-except можно вкладывать один в другой.
# Python никак нас не ограничивает в количестве таких вложений.
# try:
#     file = open('ДатаВремя.txt', encoding='utf-8')
#     try:
#         text = file.read()
#     finally:
#         file.close()
# except FileNotFoundError:
#     print('Файл с указанным именем не найден!')
# except:
#     print('Произошла ошибка!')


# Общий шаблон
# try:
#     # контролируемый код
# except (ValueError, IndexError, KeyError):       # можем обработать несколько ошибок
#     # код обработки ошибки (исключения)
# except тип_ошибки_2:                             # except может быть сколько угодно
#     # код обработки ошибки (исключения)
# except тип_ошибки_n:                             # блок для обработки непредусмотренных ошибок в пунктах выше
#     # код обработки ошибки (исключения)
# else:
#     # код для случая, если ошибки не было
# finally:
#     # код, который выполняется всегда


# Если нужен доступ к сгенерированному исключению как к объекту, то
# try:
#     nums = [10, 5, 20, 25]
#     print(nums[100])
# except (KeyError, IndexError) as err:    # записываем сгенерированное исключение в переменную err
#     print(err)                           # list index out of range
#     print(type(err))                     # <class 'IndexError'>
