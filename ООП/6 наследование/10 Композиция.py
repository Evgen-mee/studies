# Композиция представляет собой ситуацию, когда экземпляр одного класса включает в себя экземпляр другого класса.
#
# Класс, экземпляр которого содержит экземпляр другого класса, называют составным
#
# Класс, экземпляр которого содержится в экземпляре другого класса, называют компонентным
#
# Композиция описывается словом имеет: кошка имеет лапы, автомобиль имеет двигатель

# изменения в компонентном классе редко влияют на составной класс,
# а изменения в составном классе никогда не влияют на компонентный класс.

# в качестве правила, определяющего отношение между классами, предлагается выбор слова,
# связывающего эти классы: является или имеет.
#
# Наследование используется, когда класс хочет получить весь функционал родительского класса,
# а затем расширить его, определив новые методы, или изменить, переопределив уже имеющиеся.


# class Salary:
#     def __init__(self, pay, bonus):
#         self.pay = pay                                        # ежемесячная зарплата
#         self.bonus = bonus                                    # ежегодная премия
#
#     def annual_salary(self):
#         return 12 * self.pay + self.bonus                     # годовая зарплата
#
# class Employee:
#      def __init__(self, name, pay, bonus):
#          self.name = name
#          self.salary = Salary(pay, bonus)                     # объект, содержащий все данные о зарплате
#
#      def total_salary(self):
#          return self.salary.annual_salary()
#
#
# employee = Employee('Гвидо', 100000, 10000)
#
# print(employee.total_salary())


# Пример композиции: экземпляр компонентного класса создается внутри экземпляра
# составного класса и не существует отдельно от него
#
# class Salary:
#     def __init__(self, pay, bonus):
#         self.pay = pay
#         self.bonus = bonus
#
# class Employee:
#      def __init__(self, name, pay, bonus):
#          self.name = name
#          self.salary = Salary(pay, bonus)
#
#
# employee = Employee('Гвидо', 100000, 10000)

# Пример агрегации: экземпляр компонентного класса создается отдельно от экземпляра составного класса и
# передается в качестве аргумента при создании второго
#
# class Salary:
#     def __init__(self, pay, bonus):
#         self.pay = pay
#         self.bonus = bonus
#
# class Employee:
#      def __init__(self, name, salary):
#          self.name = name
#          self.salary = salary
#
#
# salary = Salary(100000, 10000)
# employee = Employee('Гвидо', salary)












