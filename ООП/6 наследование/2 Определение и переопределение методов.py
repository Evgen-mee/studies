# в дочерних классах могут быть определены как собственные новые методы,
# так и переопределены методы родительского класса

# Переопределять в дочернем классе можно как обычные методы, так и магические.

# переопределением метода родительского класса это
# определение метода в дочернем классе, имеющего то же имя, что и метод родительского класса

# вызываемый метод в первую очередь ищется в дочернем классе
# далее в родительском, таким образом работает переопределение

# для добавления атрибутов в дочернем классе переопределим __init__
# но так же для сокращения кода в дочернем классе вызовем родительский __init__!!!


# super()
# Объект, возвращаемый функцией super() называют прокси-объектом или объектом-посредником
# Его целью является осуществление доступа к родительскому классу текущего класса
#
# при вызове родительского метода с помощью функции super()
# экземпляр класса в качестве первого аргумента передавать не нужно (self)
#
# По умолчанию функция super() сама определяет:
# текущий класс
# его родительский класс
# текущий экземпляр текущего класса
# текущий класс и текущий экземпляр этого класса мы можем указывать явно
# super(Cat, self).__init__(name, age)
# Первым аргументом должен идти класс, над которым мы будем искать,
# а НЕ в котором, если выбрать класс Animal, то у нас будет TypeError,
# так как мы пойдем в класс object, где вряд ли найдем подобный инит, принимающий столько аргументов)
#
# особенностью функции super() является то что она предоставляет доступ
# ко всей иерархии классов
# если в наследовании участвует три или более классов,
# то функция super() выполняет поиск необходимого метода в каждом из этих классов (согласно иеррархии наследования)


# class Animal:                                       # родительский класс
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age
#
#     def sleep(self):
#         return f'{self.name} спит zZ'
#
# class Cat(Animal):                                         # класс наследник
#     def __init__(self, name, age, eyecolor):               # принимаем параметры как для родителя так и для дочернего
#         super().__init__(name, age)                        # вызываем инициализатор родительского класса
#         self.eyecolor = eyecolor                           # определяем атрибут дочернего класса
#
#     def sleep(self):                                       # переопределяем метод родительского класса
#         return f'{self.name} очень крепко спит zZ'
#
#     def jump(self):                                        # добавляем метод дочернего класса
#         return f'{self.name} прыгает!'
#
#
# cat = Cat('Кемаль', 1, 'желтый')
#
# print(cat.jump())


