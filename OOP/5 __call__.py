# Магический метод __call__. Функторы и классы-декораторы
# dunder-методы
# метод __call__ автоматически вызывается при вызове класса
# CLASS() а именно в ( )
# благодоря __call__ КЛАСС (не экземпляры) можем вызывать подобно функциям

# может заменить замыкание функций

# классы которые возвращают через () значения
# называются функторы

# т.к __call__(self, *args, **kwargs)
# может принимать произвольное количество параметров
# c = Counter() создали экземпляр класса
# в котором определен __call__(self,"НУЖНЫЙ АТРИБУТ" = 0 *args, **kwargs)
# с(100) передали параметры при вызове в __call__ для дальнейшей логике работы

class Counter:
    def __init__(self):
        self.__counter = 0

    # ПО УМОЛЧАНИЮ ЕСЛЕ МЕТОД НЕ ПЕРЕОПРЕДЕЛЕН
    # Вначале вызывается метод __new__ может принимать значения *args, **kwargs
    # а потом вызывается иницилизатор этого обьекта __init__
    def __call__(self, *args, **kwargs):
        obj = self.__new__(self, *args, **kwargs)
        self.__init__(obj, *args, **kwargs)
        return obj


    # метод для экземпляров класса
    def __call__(self, *args, **kwargs): # можно передовать произвольное колличество аргументов
        self.__counter += 1 # увеличиваем локальный атрибут экземпляра класса
        return self.__counter # при вызове во вне класса вернем self.__counter


    # c = Counter() создали экземпляр класса
    # x = c()  на выходе x = 1 вызаветься метод __call__
    # т.к. определили __call__ для экземпляра класса
    # теперь () возвращают заданное значение



# может заменить замыкание функций

class StripChars:
    def __init__(self, chars):
        self.__chars = chars

    def __call__(self, *args, **kwargs):
        if not isinstance(args[0],str): # проверили что в args строка
            raise TypeError("неверный тип данных")

        # вернули строку с удаленными значениями self.__chars = chars
        return args[0].strip(self.__chars)

    # s1 = StripChars("?.;:")
    # res = s1("Hello :word?")
    # на выходе res = "Hello word"


# Декоратор на уровне класса
# Вычисление производной

# функция для класса декоратора
import math


class Derivate:
    # передаем функцию функционал которой будем расширять func
    def __init__(self, func):
        self.__fn = func # ссылка на переданную функцию

    # передаем значения x и dx
    def __call__(self, x ,dx=0.0001, *args, **kwargs):
        return (self.__fn(x+dx) - self.__fn(x)) / dx

@Derivate # пременили декоратор к функции
def df_sin(x):
    return math.sin(x)

# теперь df_sin () принимает параметры для __call__(self, x ,dx=0.0001, *args, **kwargs):
# т.е. можем передовать больше одного параметра согласно логике работы декоратора