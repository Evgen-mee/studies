# метод __eq__() - для равенства ==
# метод __ne__() - для НЕ равенства != если не определен отработает инвертированный __eq__

# сравнение на равенство по умолчанию является сравнением на идентичность
# если в классе не определено, как будет происходить сравнение с помощью оператора
# == оно будет равносильно сравнению с помощью is


# Когда мы сравниваем два объекта с помощью оператора ==,
# Python автоматически вызывает данный метод у левого операнда,
# передавая методу в качестве аргумента правый операнд.
# То есть выражение p1 == p2 равносильно вызову p1.__eq__(p2)


# если мы попробуем вызвать метод __eq__() у объекта, в классе которого данный метод не реализован,
# вместо значений True или False мы получим значение NotImplemented.


# Python сначала вызывает метод __eq__() у первого объекта p1, и если метод возвращает
# значение True или False, оно становится результатом сравнения.
#
# Но если метод возвращает константу NotImplemented, Python вызывает метод __eq__() у второго объекта p2
#
# если метод вновь возвращает NotImplemented, результатом сравнения становится значение False
#
# так как p1 не знает, как сравнивать себя с p2, как и p2 не знает, как сравнивать себя с p1


# константу NotImplemented рекомендуется возвращать в методе __eq__(),
# если сравнение для объектов каких-либо типов не определено.

# !!!помимо сравнения с помощью оператора ==, также вызывается при проверке на принадлежность с помощью оператора in!!!


# class Point:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def __eq__(self, other):
#         if isinstance(other, Point):                        # проверка на тип
#             return self.x == other.x and self.y == other.y  # сравнили парметры
#         return NotImplemented                               # есле проверка не прошла вернули NotImplemented
#
#
# p1 = Point(1, 2)
# p2 = Point(1, 2)
#
# print(p1 == p2)             # True
# print(p1 == None)           # False
# print(p1 == (1, 2))         # False

