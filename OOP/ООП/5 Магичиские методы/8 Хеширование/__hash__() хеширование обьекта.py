# если в классе не определено, как будет происходить сравнение с помощью оператора ==,
# оно будет равносильно сравнению с помощью оператора is

# По умолчанию все пользовательские классы являются хешируемыми
# и имеют реализованный магический метод __hash__(),
# который и вызывает встроенная функция hash().

# по умолчанию использует идентификатор объекта.
# А именно, базовая реализация метода __hash__()
# возвращает значение id(obj) // 16

# __eq__() и __hash__() реализованы таким образом, что экземпляры этих классов
# равны только сами себе и не равны никаким другим объектам,
# а сравнения на равенство (x == y),
# идентичность (x is y)
# и сравнение хеш-значений (hash(x) == hash(y))
# являются эквивалентными операциями.

# Hash-Equal контракт
# Методы __eq__() и __hash__() тесно связаны друг с другом,
# и при реализации одного метода, нужно думать над реализацией другого.
# Так, если два объекта являются равными, то должны быть равны и их хеш-значения.
# Если два объекта имеют различные хеш-значения, то и сами объекты должны быть различны.

# правила при создании хешируемого класса!!!
# 1) Если пользовательский класс не переопределяет метод __eq__(),
# то он не должен переопределять метод __hash__()
#
# 2) Если ИЗменяемый пользовательский класс переопределяет метод __eq__(),
# то он не должен переопределять метод __hash__()
#
# 3) Если НЕизменяемый пользовательский класс переопределяет метод __eq__(),
# то переопределение метода __hash__() остается на выбор.
# Однако если он переопределяет метод __hash__(), то он должен быть реализован таким образом,
# чтобы равные экземпляры имели одинаковые хеш-значения!!!!!

# Если пользовательский класс не имеет согласованных рабочих методов __hash__() и __eq__(),
# то его экземпляры не могут быть ключами в словарях и элементами в множествах.!!!!

# class Point:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def __eq__(self, other):                            # определили поведение при ==
#         if isinstance(other, Point):
#             return self.x == other.x and self.y == other.y
#         return NotImplemented
#
#     def __hash__(self):
#         return hash((self.x, self.y))                    # вернули хеш всех атрибутов
#
#
# p1 = Point(1, 2)
# p2 = Point(1, 2)
#
# print(p1 == p2)               # True
# print(hash(p1) == hash(p2))   # True


# класс переопределяет метод __eq__(), но не переопределяет метод __hash__().
# В таком случае метод __hash__() будет иметь значение None
# при попытке вычислить хеш-значение экземпляра такого класса будет возбуждено исключение TypeError
# class Point:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def __eq__(self, other):
#         if isinstance(other, Point):
#             return self.x == other.x and self.y == other.y
#         return NotImplemented
#
#
# p = Point(1, 2)
# print(Point.__hash__)   # None
# print(hash(p))          # TypeError: unhashable type: 'Point'


# когда сравнение экземпляров класса и вычисление их хеш-значений происходит на основе атрибутов,
# удобно определить свойство, возвращающее кортеж с этими атрибутами.
# class Point:
#     def __init__(self, x, y, z):
#         self.x = x
#         self.y = y
#         self.z = z
#
#     def __eq__(self, other):
#         if isinstance(other, Point):
#             return self._fields == other._fields
#         return NotImplemented
#
#     def __hash__(self):
#         return hash(self._fields)
#
#     @property
#     def _fields(self):
#         return self.x, self.y, self.z
#
#
# p1 = Point(1, 2, 3)
# p2 = Point(1, 2, 3)
# p3 = Point(4, 5, 6)
#
# print(p1 == p2)               # True
# print(p1 == p3)               # False
# print(hash(p1) == hash(p2))   # True
# print(hash(p1) == hash(p3))   # False






