# Особенности итерируемых объектов и итераторов:
# любой объект, не вызывающий исключение TypeError при передаче в функцию iter(), — итерируемый объект
# любой объект, не вызывающий исключение TypeError при передаче в функцию next(), — итератор
# любой объект, возвращающий сам себя при передаче в функцию iter(), — итератор

# После реализации в классе метода __iter__(), экземпляры данного класса можно преобразовывать
# в коллекции с помощью встроенных функций list(), set(), tuple() и str()

# range не являются итераторами несмотря на то, что не хранят все свои элементы явно!!!!!!

# У всех ИТЕРИРУЕМЫХ ОБЬЕКТАХ есть магический метод __iter__(), который преобразует итерируемый объект в итератор.
# Встроенная функция iter() вызывает за кулисами именно этот магический метод.
#
# words = ['hello', 'beegeek', 'python']
# iterator = iter(words)                    # равнозначно words.__iter__()
# print(type(words))     # <class 'list'>
# print(type(iterator))  # <class 'list_iterator'>


# У всех ИТЕРАТОРОВ есть магический метод __next__(), который обеспечивает выдачу очередного элемента.
# Встроенная функция next() вызывает за кулисами именно этот магический метод.
#
# words = ['hello', 'beegeek', 'python']
# iterator = iter(words)                    # равнозначно words.__iter__()
# print(next(iterator))    # hello          # равнозначно iterator.__next__()
# print(next(iterator))    # beegeek        # равнозначно iterator.__next__()


# Когда элементы в итераторе закончились,
# очередной вызов функции next() возбуждает исключение StopIteration


# Если объект итератором не является, то есть у него нет магического метода __next__(),
# то вызов функции next() приведет к ошибке.
#
# words = ['hello', 'beegeek', 'python']
# print(next(words))  # TypeError: 'list' object is not an iterator


# У всех итераторов есть и метод __iter__(), который возвращает сам итератор (сам себя).
# любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором.


# Если циклу for передается не итератор, а итерируемый объект, то его метод __iter__()
# должен возвращать не сам объект, а итератор на основе этого итерируемого объекта.


# iter(callable, sentinel) -> iterator
# Если функции iter() передается два аргумента, то первый аргумент callable должен являться функцией,
# а второй аргумент sentinel — некоторым стоп-значением.
# В этом случае, созданный итератор будет вызывать указанную функцию callable и проверять полученное значение
# на равенство со значением sentinel.
# Если полученное значение равно sentinel, то возбуждается исключение StopIteration,
# иначе итератор выдает значение, полученное из функции callable.