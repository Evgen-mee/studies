# Объект считается последовательностью, если он ведет себя как последовательность.

# Для реализации протокола изменяемой последовательности
# необходимо определить следующие магические методы:
#
#  - __len__() — определяет поведение при передаче в функцию len(),
# возвращает количество элементов в последовательности
#
#  - __getitem__() — определяет поведение при доступе к элементу, используя синтаксис self[key]
#
#  - __iter__() — определяет поведение при передаче в функцию iter(), возвращает итератор для последовательности
#
#  - __contains__() — определяет поведение при проверке на принадлежность с помощью оператора in (not in)
#
# использование методов ниже делает класс изменяемым
#
#  - __setitem__() — определяет поведение при присваивании значения элементу, используя синтаксис self[key] = value
#
#  - __delitem__() — определяет поведение при удалении элемента с помощью оператора del


# если  определены __len__() и __getitem__() то __iter__() и __contains__() можно не определять!!!!!
# Python самостоятельно перебирает всю последовательность
# интерпретатор следующие шаги для создания итератора с использованием методов __len__ и __getitem__:
#
# 1) При вызове итерации (например, в цикле for или при передаче в функцию, ожидающую итерируемый объект),
# интерпретатор проверяет, есть ли у объекта метод __iter__.
# Если метод __iter__ определен, он будет использоваться для создания итератора.
# Если метод __iter__ отсутствует, интерпретатор переходит ко второму шагу.
#
# 2) Интерпретатор вызывает метод __len__ для получения длины последовательности объекта.
# Это позволяет интерпретатору знать, сколько элементов должно быть в итераторе.
#
# 3) Интерпретатор создает временный итератор, используя метод __getitem__.
# Он начинает с индекса 0 и последовательно вызывает метод __getitem__ с инкрементированным индексом,
# пока индекс не станет больше или равен длине объекта, полученной из метода __len__.
# Полученные элементы передаются в итерационный контекст, где их можно использовать в цикле или внутри функции.
#
# 4) Если при итерации метод __getitem__ возвращает элементы до последнего элемента объекта,
# интерпретатор прекращает дальнейшую итерацию и выходит из цикла или функции.


# если в классе определен магический метод __len__(), но не определен магический метод __bool__(),
# то именно __len__() будет использоваться для всех логических приведений.
# можем  экземпляры в функцию choice() модуля random

# class Order:
#     def __init__(self, cart, customer):
#         self.cart = list(cart)
#         self.customer = customer
#
#     def check_key(self, key):                   # отдельный метод для проверки индекса на корректность
#         if not isinstance(key, int):
#             raise TypeError('Индекс должен быть целым числом')
#         if key < 0 or key >= len(self.cart):
#             raise IndexError('Неверный индекс')
#         return key
#
#     def __len__(self):
#         return len(self.cart)
#
#     def __getitem__(self, key):                  # key принимает индекс
#         key = self.check_key(key)
#         return self.cart[key]
#
#     def __contains__(self, item):                # item принимает объект, наличие которого требуется проверить
#         return item in self.cart
#
#     def __iter__(self):
#         yield from self.cart
#
#     def __setitem__(self, key, value):         # принимает индекс (key), а после устанавливаемое значение (value).
#         key = self.check_key(key)
#         self.cart[key] = value
#
#     def __delitem__(self, key):
#         key = self.check_key(key)
#         del self.cart[key]
#
#
# order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')
#
# print(*order, sep=', ')  # банан, яблоко, лимон
#
# order[1] = 'ананас'
# del order[2]
#
# print(*order, sep=', ')  # банан, ананас