# Магические методы __eq__ и __hash__
# Экземпляры класса считаються не изменяемыми типами
# можно передавать в hash()

# метод hash() позволяет вычислить хеш неизменяемых обьектов
# в случае изменяемого типа данных получим ошибку

# Если обьекты a==b(равны) то равен и их хэш
# Равные хеши: hash(a)==hash(b) не гарантирвуют равенство обьектов
# если хеши не равны : hash(a) != hash(b) то обьекты точно не равны

# в словаре храниться (хеш ключа, ключ) : значение
# поиск в словаре происходит по хешу т.к. ускаряет поиск

# при переопределении __eq__(==) стандартный hash() перестает работать с обьектом класса
# поэтому нужно переопределить в классе __hash__

#С маг __eq__ без __hash не будет хэша и нельзя будет добавить в словарь, а c маг __hash__  без __eq__  будет хэш,
# но будут объекты отличаться в словаре при проверки схожести ключей и добавить два ключа


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # при переопределении __eq__(==) hash() перестает работать с обьектом класса
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    # поэтому нужно переопределить  __hash__
    def __hash__(self):
        return hash((self.x, self.y)) # вернули кортеж который примит обычная функция hash()



#  Магический метод __bool__ определения правдивости объектов
# метод bool() всегда возвращает True если нет переопределения в классе __bool__() или __len__()

# при определении в классе __len__() (без __bool__())
# при вызове вне класса bool("Обьект класса")
# bool вернет значение __len__()
# пустая или не пустая коллекция либо имеет атрибут класса значение отличимое от НУЛЯ или None

# __len__() вызывается функцией bool() если не определен __bool__()
# __bool__() вызывается в приоритетном порядке функцией bool()

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __bool__(self):
        return self.x == self.y
