# Множественное наследование

# при множественном наследовании
# параметры для инициализатора принимает только первый класс
# у остальных родителей в инизиализаторе только self

# у одного класса может быть несколько предков
# если у класса есть ряд наследников и доп функционал нужен нескольким из них
# то целесобразно создать отдельный класс с нужным функционалом
# и наследоваться от него в те классы где он нужен

# print(класс.__mro__) выведит список классов наследования

# если функция в обоих родитялях с одним названием то
# что бы вызвать функцию определенного родителя

# если разово хотим вызвать метод
# класс.нужная функция (экземпляр класса)

# если на постоянной основе хотим использовать
# то переопределяем функцию в дочернем классе

class Goods: # базовый класс
    def __init__(self, name, weight, price):
        # ЧТО БЫ СРАБОТАЛ ИНИЦИАЛИЗАТОР Mixin класса
        # ОБЯЗАТЕЛЬНО В ГЛАВНОМ КЛАССЕ ПРОПИСЫВАЕМ
        super().__init__() # обратились к классу посреднику что бы он вызвал инецилизатор второго класса
        self.name = name
        self.weight = weight
        self.price = price


    def p_info(self): # функция с одинаковым именем в двух родителях
        print("class Goods")


class MixinLog: # класс осуществляет доп функционал
    ID = 0
    def __init__(self):
        self.ID += 1
        self.id = MixinLog.ID

    def save_sell_log(self):
        print(f"{self.id} id obj")

    def p_info(self): # функция с одинаковым именем в двух родителях
        print("class MixinLog")



class Notebook(Goods, MixinLog): # один из классов наследников в котором нужно реализовать доп.функционал
    # переопределили какая функция будет вызываться
    def p_info(self):  # функция с одинаковым именем в двух родителях
        MixinLog.p_info(n) # вызывается функция определенного родителя

n = Notebook("Acer",1.3, 30000)
#
# # что бы вызвать функцию определенного родителя или переопределяем в дочернем классе
# MixinLog.p_info(n)
# n.p_info()
