








# Инициализатор __init__ и финализатор __del__

class Point:
    # КОНСТРУКТОР иницилизатор обьекта класса
    def __init__(self, x = 0, y = 0):
        print("вызвался конструктор")
        self.x = x
        self.y = y

    #ДЕСТРУКТОР финализатор класса
    def __del__(self):
        print("удаление экземпляра" + str(self))



# Магический метод __new__. Пример паттерна Singleton
# __init__(self) вызывается после создания обьекта
# __new__(cls) вызывается перед созданием обьекта

# self ссылается на созданный экземпляр класса
# # cls ссылается на класс
# class Point:
#     def __new__(cls, *args, **kwargs): # ДОЛЖЕН ВЕРНУТЬ АДРЕС НОВОГО СОЗДАННОГО ОБЬЕКТА
#         print("Вызов new для " +str(cls))
#         return super().__new__(cls) # возвращаем адрес нового обьекта
#     # super() ссылка на базовый класс
#
#
#     def __init__(self, x = 0, y = 0):
#         print("Вызов init для " + str(self))
#         self.x = x
#         self.y = y
#
#
# pt = Point(1,2)
#
#
# class DataBase:
#     __instance = None # ссылка на экземпляр класса МОЖНО ПРОВЕРЯТЬ СУЩЕСТВУЕТ ИЛИ НЕТ ЭКЗЕМПЛЯР КЛАССА
#
#     def __new__(cls, *args, **kwargs):
#         if cls.__instance is None: # Если обьект не существует то присвоим адрес (создадим обьект )
#             cls.__instance = super().__new__(cls)
#         return cls.__instance # если обьект создан то просто вернем адре существующего обьекта
#
#     def __del__(self): # добавили финилизатор для того что бы
#         DataBase.__instance = None # при удалении существующего обьекта флаг __instance сменился на None и обьект можно было создать
#
# el1 = DataBase(2,3,4)
# el2 = DataBase(10,20,30)
# # обе переменные el1 и el2  ссылаються на один и тот же обьект
# # НО ЕСЛИ НЕ РЕАЛИЗОВАТЬ def __call__((cls, *args, **kwargs):)
# # при вызове в обьекте будет 10,20,30 так как отработает __init__ и переопределит свойства





