# 1 Классы и объекты. Атрибуты классов и объектов
# 2 Методы классов. Параметр self
# 3 Инициализатор __init__ и финализатор __del__
# 4 Магический метод __new__.


# атрибут  = свойство класса
# локальный атрибут = свойство функции или класса то что вложенно в класс
import math


# print(экземпляр класса.___dict___) выводит локальные свойства класса
# print(класс.___dict___) выводит атрибуты класса

# class Vector: < -------------- Имя Класс
# MIN = 100 , MAX = 100 < атрибут класса
# def __init__(self, ): < атрибут класса, метод класса
# self.coords = (1, 2) < -----------------------локальное свойство?
# pt = Vector(...) < ---------------- экземпляр класса

# Классы и объекты. Атрибуты классов и объектов
#class Point: # определили класс
    #"ОПИСАНИЕ КЛАССА"
#pass # указали что он пустой
    ##circle = 2

# метод Point.__doc__ выведет описпние класса

#a = Point() # Создали экземпляр класса
# до того как присвоили значение в свойства обьекта
# обьект ссылался на класс
# в момент присвоения нового значения атрибута
# оператор = создал в обьекте сdойство со значением blac
#a.color = "blac"



# что бы добавить новое свойство в класс или экземпляр
#Point.имя атрибута = "1000"
# или используем
# метод setattr(Point, "имя атрибута", 1000)
# если атрибут существует то просто поменяется значение на новое

# метод getattr(Point,"a", False) позволяет при обращении к НЕСУЩЕСТВУЮЩЕМУ свойству избежать ошибки
# если метод класса не существует в данном классе то вернется третий аргумент метода getattr(Point,"a", False)
# False

# Удалить атрибуты класса
# del Point.prop при удалении не существующих методов вылетит ошибка
# delattr(Point,"a") при удалении не существующих методов вылетит ошибка
# что бы избежать ошибки при удалении В КЛАССЕЕ используем
# метод hasattr(Point,"a") вернет True если свойство существует в классе
# если обратиться к обьекту класса к свойству класса то
# метод hasattr(a,"a") вернет True тк a ссылается на атрибут класса (если не переопределен)
# соответственно даже если hasattr(a,"a")True (если атрибут обьекта не переопределен)
# и используем del Point.prop вылетит ошибка тк атрибута а не существует в обьекте

# после удаления переопределенного атрибута обьекта
# обьект по этому же (удаленному(переопределенному)) атрибуту будет ссылаться на атрибут класса
# a.color после удаления = a.color = Point.color = "red"

# проверка на наличие свойства в обьекте "нужное свойство" in обьект.__dict__


#Методы классов. Параметр self
# self = this
# что бы можно было вызывать метод класса через обьект
# при обьявлении в классе указываем ПЕРВЫМ ПАРАМТРОМ self
# def foo(self, x , y):
# при данном обьявлении вызов через класс приведет к ошибке

# что бы добавить определенные свойства в экземпляр но не добавлять в класс
# в классе можно создать соответствующий метод
# при вызове которого в экземпляр добавяться атрибуты ЭКЗЕМПЛЯРА
# def foo(self, x , y):
# self.x = x
# self.y = y



# Инициализатор __init__ и финализатор __del__

class Point:
    # КОНСТРУКТОР иницилизатор обьекта класса
    def __init__(self, x = 0, y = 0):
        print("вызвался конструктор")
        self.x = x
        self.y = y

    #ДЕСТРУКТОР финализатор класса
    def __del__(self):
        print("удаление экземпляра" + str(self))



# Магический метод __new__. Пример паттерна Singleton
# __init__(self) вызывается после создания обьекта
# __new__(cls) вызывается перед созданием обьекта

# self ссылается на созданный экземпляр класса
# cls ссылается на класс
class Point:
    def __new__(cls, *args, **kwargs): # ДОЛЖЕН ВЕРНУТЬ АДРЕС НОВОГО СОЗДАННОГО ОБЬЕКТА
        print("Вызов new для " +str(cls))
        return super().__new__(cls) # возвращаем адрес нового обьекта
    # super() ссылка на базовый класс


    def __init__(self, x = 0, y = 0):
        print("Вызов init для " + str(self))
        self.x = x
        self.y = y


pt = Point(1,2)


class DataBase:
    __instance = None # ссылка на экземпляр класса МОЖНО ПРОВЕРЯТЬ СУЩЕСТВУЕТ ИЛИ НЕТ ЭКЗЕМПЛЯР КЛАССА

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None: # Если обьект не существует то присвоим адрес (создадим обьект )
            cls.__instance = super().__new__(cls)
        return cls.__instance # если обьект создан то просто вернем адре существующего обьекта

    def __del__(self): # добавили финилизатор для того что бы
        DataBase.__instance = None # при удалении существующего обьекта флаг __instance сменился на None и обьект можно было создать

el1 = DataBase(2,3,4)
el2 = DataBase(10,20,30)
# обе переменные el1 и el2  ссылаються на один и тот же обьект
# НО ЕСЛИ НЕ РЕАЛИЗОВАТЬ def __call__((cls, *args, **kwargs):)
# при вызове в обьекте будет 10,20,30 так как отработает __init__ и переопределит свойства